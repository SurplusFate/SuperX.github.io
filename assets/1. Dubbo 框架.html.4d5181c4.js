import{_ as n}from"./_plugin-vue_export-helper.cdc0426e.js";import{o as i,c as s,a as e,b as o,d as t,e as a,r as b}from"./app.a8d69520.js";const l={},h=e("h1",{id:"dubbo-框架",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#dubbo-框架","aria-hidden":"true"},"#"),o(" Dubbo 框架")],-1),d=e("p",null,"Apache Dubbo (incubating) |ˈdʌbəʊ| 是一款高性能、轻量级的开源Java RPC 框架，它提供了三大核心能力：面向接口的远程方法调用，智能容错和负载均衡，以及服务自动注册和发现。",-1),u=e("p",null,[o("Dubbo 是一个分布式服务框架，致力于提供高性能和透明化的 "),e("strong",null,"RPC"),o(" 远程服务调用方案、服务治理方案。")],-1),c={href:"https://dubbo.apache.org/zh/index.html",target:"_blank",rel:"noopener noreferrer"},p=a('<h2 id="dubbo-核心特性" tabindex="-1"><a class="header-anchor" href="#dubbo-核心特性" aria-hidden="true">#</a> Dubbo 核心特性</h2><h3 id="高性能-rpc-通信协议" tabindex="-1"><a class="header-anchor" href="#高性能-rpc-通信协议" aria-hidden="true">#</a> 高性能 RPC 通信协议</h3><p>跨进程或主机的服务通信是 Dubbo 的一项基本能力，Dubbo RPC 以预先定义好的协议编码方式将请求数据（Request）发送给后端服务，并接收服务端返回的计算结果（Response）。RPC 通信对用户来说是完全透明的，使用者无需关心请求是如何发出去的、发到了哪里，每次调用只需要拿到正确的调用结果就行。除了同步模式的 Request-Response 通信模型外，Dubbo3 还提供更丰富的通信模型选择：</p><ul><li>消费端异步请求 (Client Side Asynchronous Request-Response)</li><li>提供端异步执行（Server Side Asynchronous Request-Response）</li><li>消费端请求流（Request Streaming）</li><li>提供端响应流（Response Streaming）</li><li>双向流式通信（Bidirectional Streaming）</li></ul>',4),_={href:"https://dubbo.apache.org/zh/docs3-v2/java-sdk/concepts-and-architecture/triple/",target:"_blank",rel:"noopener noreferrer"},f=e("h3",{id:"自动服务-地址-发现",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#自动服务-地址-发现","aria-hidden":"true"},"#"),o(" 自动服务（地址）发现")],-1),g=e("p",null,"Dubbo 的服务发现机制，让微服务组件之间可以独立演进并任意部署，消费端可以在无需感知对端部署位置与 IP 地址的情况下完成通信。Dubbo 提供的是 Client-Based 的服务发现机制，使用者可以有多种方式启用服务发现：",-1),D={href:"https://nacos.io/",target:"_blank",rel:"noopener noreferrer"},m=e("li",null,"将服务的组织与注册交给底层容器平台，如 Kubernetes，这被理解是一种更云原生的使用方式",-1),v=e("h3",{id:"运行态流量管控",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#运行态流量管控","aria-hidden":"true"},"#"),o(" 运行态流量管控")],-1),x=e("p",null,"透明地址发现让 Dubbo 请求可以被发送到任意 IP 实例上，这个过程中流量被随机分配。当需要对流量进行更丰富、更细粒度的管控时，就可以用到 Dubbo 的流量管控策略，Dubbo 提供了包括负载均衡、流量路由、请求超时、流量降级、重试等策略，基于这些基础能力可以轻松的实现更多场景化的路由方案，包括金丝雀发布、A/B 测试、权重路由、同区域优先等，更酷的是，Dubbo 支持流控策略在运行态动态生效，无需重新部署。具体可参见：",-1),R={href:"https://dubbo.apache.org/zh/overview/tasks/traffic-management",target:"_blank",rel:"noopener noreferrer"},k=e("h3",{id:"丰富的扩展组件及生态",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#丰富的扩展组件及生态","aria-hidden":"true"},"#"),o(" 丰富的扩展组件及生态")],-1),q={href:"https://github.com/apache/dubbo-spi-extensions",target:"_blank",rel:"noopener noreferrer"},C={href:"https://dubbo.apache.org/zh/overview/what/ecosystem",target:"_blank",rel:"noopener noreferrer"},P={href:"https://dubbo.apache.org/zh/overview/what/extensibility",target:"_blank",rel:"noopener noreferrer"},S=a('<h3 id="面向云原生设计" tabindex="-1"><a class="header-anchor" href="#面向云原生设计" aria-hidden="true">#</a> 面向云原生设计</h3><p>Dubbo 从设计上是完全遵循云原生微服务开发理念的，这体现在多个方面，首先是对云原生基础设施与部署架构的支持，包括 容器、Kubernetes 等，Dubbo Mesh 总体解决方案也在 3.1 版本正式发布；另一方面，Dubbo 众多核心组件都已面向云原生升级，包括 Triple 协议、统一路由规则、对多语言的支持。</p><p>值得一提的是，如何使用 Dubbo 支持弹性伸缩的服务如 Serverless 也在未来计划之中，这包括利用 Native Image 提高 Dubbo 的启动速度与资源消耗等。</p><h2 id="基本架构" tabindex="-1"><a class="header-anchor" href="#基本架构" aria-hidden="true">#</a> 基本架构</h2><p><img src="https://dubbo.apache.org/imgs/architecture.png" alt="arch-service-discovery"></p><blockquote><p>服务提供者（Provider）：暴露服务的服务提供方，服务提供者在 启动时，向注册中心注册自己提供的服务。</p><p>服务消费者（Consumer）：调用远程服务的服务消费方，服务消费者在启动时，向注册中心订阅自己所需的服务，服务消费者，从提 供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如 果调用失败，再选另一台调用。</p><p>注册中心（Registry）：注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。</p><p>监控中心（Monitor）：服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。</p></blockquote><p>调用关系说明:</p><ul><li>服务容器负责启动，加载，运行服务提供者。</li><li>服务提供者在启动时，向注册中心注册自己提供的服务。</li><li>服务消费者在启动时，向注册中心订阅自己所需的服务。</li><li>注册中心返回服务提供者地址列表给消费者，如果有变更，注册 中心将基于长连接推送变更数据给消费者。</li><li>服务消费者，从提供者地址列表中，基于软负载均衡算法，选一 台提供者进行调用，如果调用失败，再选另一台调用。</li><li>服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。</li></ul><h2 id="dubbo-支持的协议" tabindex="-1"><a class="header-anchor" href="#dubbo-支持的协议" aria-hidden="true">#</a> dubbo 支持的协议</h2><p>支持多种协议：dubbo , hessian , rmi , http, webservice , thrift ,memcached , redis。</p><p>dubbo 官方推荐使用 dubbo 协议。</p><p>dubbo 协议默认端口 20880 使用 dubbo 协议，spring 配置文件加入：<code>&lt;dubbo:protocol name=&quot;dubbo&quot; port=&quot;20880&quot; /&gt;</code></p>',12);function w(y,B){const r=b("ExternalLinkIcon");return i(),s("div",null,[h,d,u,e("p",null,[e("a",c,[o("Apache Dubbo"),t(r)])]),p,e("p",null,[o("具体可参见各语言 SDK 实现的可选协议列表 或 "),e("a",_,[o("Triple 协议"),t(r)])]),f,g,e("ul",null,[e("li",null,[o("使用独立的注册中心组件，如 "),e("a",D,[o("Nacos"),t(r)]),o("、Zookeeper、Consul、Etcd 等。")]),m]),v,x,e("ul",null,[e("li",null,[e("a",R,[o("流量治理示例"),t(r)])])]),k,e("p",null,[o("Dubbo 强大的服务治理能力不仅体现在核心框架上，还包括其优秀的扩展能力以及周边配套设施的支持。通过 Filter、Router、Protocol 等几乎存在于每一个关键流程上的扩展点定义，我们可以丰富 Dubbo 的功能或实现与其他微服务配套系统的对接，包括 Transaction、Tracing 目前都有通过 SPI 扩展的实现方案，具体可以参见 Dubbo 扩展性的详情，也可以在 "),e("a",q,[o("apache/dubbo-spi-extensions"),t(r)]),o(" 项目中发现与更多的扩展实现。具体可参见：")]),e("ul",null,[e("li",null,[e("a",C,[o("Dubbo 生态"),t(r)])]),e("li",null,[e("a",P,[o("Dubbo 可扩展性设计"),t(r)])])]),S])}const z=n(l,[["render",w],["__file","1. Dubbo 框架.html.vue"]]);export{z as default};
