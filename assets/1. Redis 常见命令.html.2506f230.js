import{_ as s}from"./_plugin-vue_export-helper.cdc0426e.js";import{o as a,c as t,a as e,b as i,d as r,e as p,r as d}from"./app.9a4f068f.js";const n={},h=e("h1",{id:"redis-常见命令",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#redis-常见命令","aria-hidden":"true"},"#"),i(" Redis 常见命令")],-1),m=e("p",null,"Redis 是典型的 key-value 数据库，key 一般是字符串，而 value 包含很多不同的数据类型：",-1),o=e("p",null,[e("img",{src:"https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/202210211901967.png",alt:"image-20221020220114843"})],-1),c={href:"https://redis.io/commands",target:"_blank",rel:"noopener noreferrer"},g=p(`<p><img src="https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/202210211901867.png" alt="image-20221020220151500"></p><p>不同类型的命令称为一个 group，我们也可以通过 help 命令来查看各种不同 group 的命令：</p><p><img src="https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/202210211901811.png" alt="image-20221020220228495"></p><h2 id="redis-通用命令" tabindex="-1"><a class="header-anchor" href="#redis-通用命令" aria-hidden="true">#</a> Redis 通用命令</h2><p>通用指令是部分数据类型的，都可以使用的指令，常见的有：</p><p>KEYS：查看符合模板的所有</p><p>key DEL：删除一个指定的</p><p>key EXISTS：判断 key 是否存在</p><p>EXPIRE：给一个 key 设置有效期，有效期到期时该 key 会被自动删除</p><p>TTL：查看一个 KEY 的剩余有效期</p><p>通过 help [command] 可以查看一个命令的具体用法，例如：</p><p><img src="https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/202210211901079.png" alt="image-20221020220335818"></p><h2 id="string-类型" tabindex="-1"><a class="header-anchor" href="#string-类型" aria-hidden="true">#</a> String 类型</h2><p>String 类型，也就是字符串类型，是 Redis 中最简单的存储类型。</p><p>其 value 是字符串，不过根据字符串的格式不同，又可以分为 3 类：</p><ul><li><p>string：普通字符串</p></li><li><p>int：整数类型，可以做自增、自减操作</p></li><li><p>float：浮点类型，可以做自增、自减操作</p></li></ul><p>不管是哪种格式，底层都是字节数组形式存储，只不过是编码方式不同。字符串类型的最大空间不能超过 512m.</p><h3 id="string-的常见命令" tabindex="-1"><a class="header-anchor" href="#string-的常见命令" aria-hidden="true">#</a> String 的常见命令</h3><ul><li><p>SET：添加或者修改已经存在的一个 String 类型的键值对</p></li><li><p>GET：根据 key 获取 String 类型的 value</p></li><li><p>MSET：批量添加多个 String 类型的键值对</p></li><li><p>MGET：根据多个 key 获取多个 String 类型的 value</p></li><li><p>INCR：让一个整型的 key 自增 1</p></li><li><p>INCRBY:让一个整型的 key 自增并指定步长，例如：incrby num 2 让 num 值自增 2</p></li><li><p>INCRBYFLOAT：让一个浮点类型的数字自增并指定步长</p></li><li><p>SETNX：添加一个 String 类型的键值对，前提是这个 key 不存在，否则不执行</p></li><li><p>SETEX：添加一个 String 类型的键值对，并且指定有效期</p></li></ul><h3 id="key-结构" tabindex="-1"><a class="header-anchor" href="#key-结构" aria-hidden="true">#</a> Key 结构</h3><p>Redis 没有类似 MySQL 中的 Table 的概念，例如，需要存储用户、商品信息到 redis，有一个用户 id 是 1，有一个商品 id 恰好也是 1，此时如果使用 id 作为 key，那就会冲突了.</p><p>我们可以通过给 key 添加前缀加以区分，不过这个前缀不是随便加的，有一定的规范： Redis 的 key 允许有多个单词形成层级结构，多个单词之间用&#39;:&#39;隔开，格式如下：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>项目名:业务名:类型:id
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这个格式并非固定，也可以根据自己的需求来删除或添加词条。这样以来，我们就可以把 不同类型的数据区分开了。从而避免了 key 的冲突问题。</p><p>例如我们的项目名称叫 heima，有 user 和 product 两种不同类型的数据，我们可以这样定义 key：</p><p>user 相关的 key：<code>heima:user:1</code></p><p>product 相关的 key：<code>heima:product:1</code></p><p>如果 Value 是一个 Java 对象，例如一个 User 对象，则可以将对象序列化为 JSON 字符串后存储：</p><p><img src="https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/202210211951985.png" alt="image-20221021195109939"></p><p>并且，在 Redis 的桌面客户端中，还会以相同前缀作为层级结构，让数据看起来层次分明，关系清晰：</p><p><img src="https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/202210212023232.png" alt="image-20221021202330199"></p><h2 id="hash-类型" tabindex="-1"><a class="header-anchor" href="#hash-类型" aria-hidden="true">#</a> Hash 类型</h2><p>Hash 类型，也叫散列，其 value 是一个无序字典，类似于 Java 中的 HashMap 结构。</p><p>String 结构是将对象序列化为 JSON 字符串后存储，当需要修改对象某个字段时很不方便，Hash 结构可以将对象中的每个字段独立存储，可以针对单个字段做 CRUD：</p><p><img src="https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/202210212022838.png" alt="image-20221021202218803"></p><p>Hash 的常见命令有：</p><ul><li>HSET key field value：添加或者修改 hash 类型 key 的 field 的值</li><li>HGET key field：获取一个 hash 类型 key 的 field 的值</li><li>HMSET：批量添加多个 hash 类型 key 的 field 的值</li><li>HMGET：批量获取多个 hash 类型 key 的 field 的值</li><li>HGETALL：获取一个 hash 类型的 key 中的所有的 field 和 value</li><li>HKEYS：获取一个 hash 类型的 key 中的所有的 field</li><li>HVALS：获取一个 hash 类型的 key 中的所有的 value</li><li>HINCRBY:让一个 hash 类型 key 的字段值自增并指定步长</li><li>HSETNX：添加一个 hash 类型的 key 的 field 值，前提是这个 field 不存在，否则不执行</li></ul><h2 id="list-类型" tabindex="-1"><a class="header-anchor" href="#list-类型" aria-hidden="true">#</a> List 类型</h2><p>Redis 中的 List 类型与 Java 中的 LinkedList 类似，可以看做是一个双向链表结构。既 可以支持正向检索和也可以支持反向检索。</p><p>特征也与 LinkedList 类似：</p><ul><li>有序</li><li>元素可以重复</li><li>插入和删除快</li><li>查询速度一般</li></ul><p>常用来存储一个有序数据，例如：朋友圈点赞列表，评论列表等。</p><p>List 的常见命令有：</p><ul><li>LPUSH key element ... ：向列表左侧插入一个或多个元素</li><li>LPOP key：移除并返回列表左侧的第一个元素，没有则返回 nil</li><li>RPUSH key element ... ：向列表右侧插入一个或多个元素</li><li>RPOP key：移除并返回列表右侧的第一个元素</li><li>LRANGE key star end：返回一段角标范围内的所有元素</li><li>BLPOP 和 BRPOP：与 LPOP 和 RPOP 类似，只不过在没有元素时等待指定时间，而不是直接返回 nil</li></ul><h2 id="set-类型" tabindex="-1"><a class="header-anchor" href="#set-类型" aria-hidden="true">#</a> Set 类型</h2><p>Redis 的 Set 结构与 Java 中的 HashSet 类似，可以看做是一个 value 为 null 的 HashMap。因为也是一个 hash 表，因此具备与 HashSet 类似的特征：</p><ul><li>无序</li><li>元素不可重复 查找快</li><li>支持交集、并集、差集等功能</li></ul><p>Set 的常见命令有：</p><ul><li>SADD key member ... ：向 set 中添加一个或多个元素</li><li>SREM key member ... : 移除 set 中的指定元素</li><li>SCARD key： 返回 set 中元素的个数</li><li>SISMEMBER key member：判断一个元素是否存在于 set 中</li><li>SMEMBERS：获取 set 中的所有元素</li><li>SINTER key1 key2 ... ：求 key1 与 key2 的交集</li><li>SDIFF key1 key2 ... ：求 key1 与 key2 的差集</li><li>SUNION key1 key2 ... ：求 key1 与 key2 的并集</li></ul><p>例如两个集合：s1 和 s2:</p><p><img src="https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/202210212028895.png" alt="image-20221021202816844"></p><p>求交集：SINTER s1 s2</p><p>求 s1 与 s2 的不同：SDIFF s1 s2</p><p><img src="https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/202210212029081.png" alt="image-20221021202953036"></p><h2 id="sortedset-类型" tabindex="-1"><a class="header-anchor" href="#sortedset-类型" aria-hidden="true">#</a> SortedSet 类型</h2><p>Redis 的 SortedSet 是一个可排序的 set 集合，与 Java 中的 TreeSet 有些类似，但底层 数据结构却差别很大。</p><p>SortedSet 中的每一个元素都带有一个 score 属性，可以基于 score 属性对元素排序，底层的实现是一个跳表（SkipList）加 hash 表。</p><p>SortedSet 具备下列特性：</p><ul><li>可排序</li><li>元素不重复</li><li>查询速度快</li></ul><p>因为 SortedSet 的可排序特性（从小到大排序），经常被用来实现排行榜这样的功能。</p><p>SortedSet 的常见命令有：</p><ul><li>ZADD key score member：添加一个或多个元素到 sorted set ，如果已经存在 则更新其 score 值</li><li>ZREM key member：删除 sorted set 中的一个指定元素</li><li>ZSCORE key member : 获取 sorted set 中的指定元素的 score 值</li><li>ZRANK key member：获取 sorted set 中的指定元素的排名</li><li>ZCARD key：获取 sorted set 中的元素个数</li><li>ZCOUNT key min max：统计 score 值在给定范围内的所有元素的个数</li><li>ZINCRBY key increment member：让 sorted set 中的指定元素自增，步长为 指定的 increment 值</li><li>ZRANGE key min max：按照 score 排序后，获取指定排名范围内的元素</li><li>ZRANGEBYSCORE key min max：按照 score 排序后，获取指定 score 范围内的元素</li><li>ZDIFF、ZINTER、ZUNION：求差集、交集、并集</li></ul><div class="custom-container tip"><p class="custom-container-title">提示</p><p>所有的排名默认都是升序，如果要降序则在命令的 Z 后面添加 REV 即可，例如：</p><ul><li>升序获取 sorted set 中的指定元素的排名：ZRANK key member</li><li>降序获取 sorted set 中的指定元素的排名：ZREVRANK key memeber</li></ul></div>`,63);function u(k,S){const l=d("ExternalLinkIcon");return a(),t("div",null,[h,m,o,e("p",null,[i("Redis 为了方便我们学习，将操作不同数据类型的命令也做了分组，在官网（ "),e("a",c,[i("https://redis.io/commands"),r(l)]),i(" ）可以查看到不同的命令：")]),g])}const _=s(n,[["render",u],["__file","1. Redis 常见命令.html.vue"]]);export{_ as default};
