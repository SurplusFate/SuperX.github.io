import{_ as l}from"./_plugin-vue_export-helper.cdc0426e.js";import{o as r,c as p,a,b as e,d as i,e as n,r as t}from"./app.018e494d.js";const d={},c=n('<h1 id="_12-docker-的基本操作" tabindex="-1"><a class="header-anchor" href="#_12-docker-的基本操作" aria-hidden="true">#</a> 12. Docker 的基本操作</h1><h2 id="_12-1-镜像操作" tabindex="-1"><a class="header-anchor" href="#_12-1-镜像操作" aria-hidden="true">#</a> 12.1.镜像操作</h2><h3 id="_12-1-1-镜像名称" tabindex="-1"><a class="header-anchor" href="#_12-1-1-镜像名称" aria-hidden="true">#</a> 12.1.1.镜像名称</h3><p>首先来看下镜像的名称组成：</p><ul><li>镜名称一般分两部分组成：[repository]:[tag]。</li><li>在没有指定 tag 时，默认是 latest，代表最新版本的镜像</li></ul><p>如图：</p><p><img src="https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/image-20210731155141362.png" alt="image-20210731155141362"></p><p>这里的 mysql 就是 repository，5.7 就是 tag，合一起就是镜像名称，代表 5.7 版本的 MySQL 镜像。</p><h3 id="_12-1-2-镜像命令" tabindex="-1"><a class="header-anchor" href="#_12-1-2-镜像命令" aria-hidden="true">#</a> 12.1.2.镜像命令</h3><p>常见的镜像操作命令如图：</p><p><img src="https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/image-20210731155649535.png" alt="image-20210731155649535"></p><h3 id="_12-1-3-案例-1-拉取、查看镜像" tabindex="-1"><a class="header-anchor" href="#_12-1-3-案例-1-拉取、查看镜像" aria-hidden="true">#</a> 12.1.3.案例 1-拉取、查看镜像</h3><p>需求：从 DockerHub 中拉取一个 nginx 镜像并查看</p>',13),o={href:"https://hub.docker.com/",target:"_blank",rel:"noopener noreferrer"},u=n(`<p><img src="https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/image-20210731155844368.png" alt="image-20210731155844368"></p><p>2）根据查看到的镜像名称，拉取自己需要的镜像，通过命令：docker pull nginx</p><p><img src="https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/image-20210731155856199.png" alt="image-20210731155856199"></p><p>3）通过命令：docker images 查看拉取到的镜像</p><p><img src="https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/image-20210731155903037.png" alt="image-20210731155903037"></p><h3 id="_12-1-4-案例-2-保存、导入镜像" tabindex="-1"><a class="header-anchor" href="#_12-1-4-案例-2-保存、导入镜像" aria-hidden="true">#</a> 12.1.4.案例 2-保存、导入镜像</h3><p>需求：利用 docker save 将 nginx 镜像导出磁盘，然后再通过 load 加载回来</p><p>1）利用 docker xx --help 命令查看 docker save 和 docker load 的语法</p><p>例如，查看 save 命令用法，可以输入命令：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> save <span class="token parameter variable">--help</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>结果：</p><p><img src="https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/image-20210731161104732.png" alt="image-20210731161104732"></p><p>命令格式：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> save <span class="token parameter variable">-o</span> <span class="token punctuation">[</span>保存的目标文件名称<span class="token punctuation">]</span> <span class="token punctuation">[</span>镜像名称<span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>2）使用 docker save 导出镜像到磁盘</p><p>运行命令：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> save <span class="token parameter variable">-o</span> nginx.tar nginx:latest
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>结果如图：</p><p><img src="https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/image-20210731161354344.png" alt="image-20210731161354344"></p><p>3）使用 docker load 加载镜像</p><p>先删除本地的 nginx 镜像：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> rmi nginx:latest
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>然后运行命令，加载本地文件：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> load <span class="token parameter variable">-i</span> nginx.tar
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>结果：</p><p><img src="https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/image-20210731161746245.png" alt="image-20210731161746245"></p><h3 id="_12-1-5-练习" tabindex="-1"><a class="header-anchor" href="#_12-1-5-练习" aria-hidden="true">#</a> 12.1.5.练习</h3><p>需求：去 DockerHub 搜索并拉取一个 Redis 镜像</p><p>目标：</p><p>1）去 DockerHub 搜索 Redis 镜像</p><p>2）查看 Redis 镜像的名称和版本</p><p>3）利用 docker pull 命令拉取镜像</p><p>4）利用 docker save 命令将 redis:latest 打包为一个 redis.tar 包</p><p>5）利用 docker rmi 删除本地的 redis:latest</p><p>6）利用 docker load 重新加载 redis.tar 文件</p><h2 id="_12-2-容器操作" tabindex="-1"><a class="header-anchor" href="#_12-2-容器操作" aria-hidden="true">#</a> 12.2.容器操作</h2><h3 id="_12-2-1-容器相关命令" tabindex="-1"><a class="header-anchor" href="#_12-2-1-容器相关命令" aria-hidden="true">#</a> 12.2.1.容器相关命令</h3><p>容器操作的命令如图：</p><p><img src="https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/image-20210731161950495.png" alt="image-20210731161950495"></p><p>容器保护三个状态：</p><ul><li>运行：进程正常运行</li><li>暂停：进程暂停，CPU 不再运行，并不释放内存</li><li>停止：进程终止，回收进程占用的内存、CPU 等资源</li></ul><p>其中：</p><ul><li><p>docker run：创建并运行一个容器，处于运行状态</p></li><li><p>docker pause：让一个运行的容器暂停</p></li><li><p>docker unpause：让一个容器从暂停状态恢复运行</p></li><li><p>docker stop：停止一个运行的容器</p></li><li><p>docker start：让一个停止的容器再次运行</p></li><li><p>docker rm：删除一个容器</p></li></ul><h3 id="_12-2-2-案例-创建并运行一个容器" tabindex="-1"><a class="header-anchor" href="#_12-2-2-案例-创建并运行一个容器" aria-hidden="true">#</a> 12.2.2.案例-创建并运行一个容器</h3><p>创建并运行 nginx 容器的命令：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> run <span class="token parameter variable">--name</span> containerName <span class="token parameter variable">-p</span> <span class="token number">80</span>:80 <span class="token parameter variable">-d</span> nginx
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>命令解读：</p><ul><li>docker run ：创建并运行一个容器</li><li>--name : 给容器起一个名字，比如叫做 mn</li><li>-p ：将宿主机端口与容器端口映射，冒号左侧是宿主机端口，右侧是容器端口</li><li>-d：后台运行容器</li><li>nginx：镜像名称，例如 nginx</li></ul><p>这里的<code>-p</code>参数，是将容器端口映射到宿主机端口。</p><p>默认情况下，容器是隔离环境，我们直接访问宿主机的 80 端口，肯定访问不到容器中的 nginx。</p><p>现在，将容器的 80 与宿主机的 80 关联起来，当我们访问宿主机的 80 端口时，就会被映射到容器的 80，这样就能访问到 nginx 了：</p><p><img src="https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/image-20210731163255863.png" alt="image-20210731163255863"></p><h3 id="_12-2-3-案例-进入容器-修改文件" tabindex="-1"><a class="header-anchor" href="#_12-2-3-案例-进入容器-修改文件" aria-hidden="true">#</a> 12.2.3.案例-进入容器，修改文件</h3><p><strong>需求</strong>：进入 Nginx 容器，修改 HTML 文件内容，添加“传智教育欢迎您”</p><p><strong>提示</strong>：进入容器要用到 docker exec 命令。</p><p><strong>步骤</strong>：</p><p>1）进入容器。进入我们刚刚创建的 nginx 容器的命令为：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> mn <span class="token function">bash</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>命令解读：</p><ul><li><p>docker exec ：进入容器内部，执行一个命令</p></li><li><p>-it : 给当前进入的容器创建一个标准输入、输出终端，允许我们与容器交互</p></li><li><p>mn ：要进入的容器的名称</p></li><li><p>bash：进入容器后执行的命令，bash 是一个 linux 终端交互命令</p></li></ul><p>2）进入 nginx 的 HTML 所在目录 /usr/share/nginx/html</p><p>容器内部会模拟一个独立的 Linux 文件系统，看起来如同一个 linux 服务器一样：</p><p><img src="https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/image-20210731164159811.png" alt="image-20210731164159811"></p><p>nginx 的环境、配置、运行文件全部都在这个文件系统中，包括我们要修改的 html 文件。</p><p>查看 DockerHub 网站中的 nginx 页面，可以知道 nginx 的 html 目录位置在<code>/usr/share/nginx/html</code></p><p>我们执行命令，进入该目录：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token builtin class-name">cd</span> /usr/share/nginx/html
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>查看目录下文件：</p><p><img src="https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/image-20210731164455818.png" alt="image-20210731164455818"></p><p>3）修改 index.html 的内容</p><p>容器内没有 vi 命令，无法直接修改，我们用下面的命令来修改：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">sed</span> <span class="token parameter variable">-i</span> <span class="token parameter variable">-e</span> <span class="token string">&#39;s#Welcome to nginx#传智教育欢迎您#g&#39;</span> <span class="token parameter variable">-e</span> <span class="token string">&#39;s#&lt;head&gt;#&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;&gt;#g&#39;</span> index.html
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div>`,72),m={href:"http://192.168.150.101",target:"_blank",rel:"noopener noreferrer"},g=n(`<p><img src="https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/image-20210731164717604.png" alt="image-20210731164717604"></p><h3 id="_12-2-4-小结" tabindex="-1"><a class="header-anchor" href="#_12-2-4-小结" aria-hidden="true">#</a> 12.2.4.小结</h3><p>docker run 命令的常见参数有哪些？</p><ul><li>--name：指定容器名称</li><li>-p：指定端口映射</li><li>-d：让容器后台运行</li></ul><p>查看容器日志的命令：</p><ul><li>docker logs</li><li>添加 -f 参数可以持续查看日志</li></ul><p>查看容器状态：</p><ul><li>docker ps</li><li>docker ps -a 查看所有容器，包括已经停止的</li></ul><h2 id="_12-3-数据卷-容器数据管理" tabindex="-1"><a class="header-anchor" href="#_12-3-数据卷-容器数据管理" aria-hidden="true">#</a> 12.3.数据卷（容器数据管理）</h2><p>在之前的 nginx 案例中，修改 nginx 的 html 页面时，需要进入 nginx 内部。并且因为没有编辑器，修改文件也很麻烦。</p><p>这就是因为容器与数据（容器内文件）耦合带来的后果。</p><p><img src="https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/image-20210731172440275.png" alt="image-20210731172440275"></p><p>要解决这个问题，必须将数据与容器解耦，这就要用到数据卷了。</p><h3 id="_12-3-1-什么是数据卷" tabindex="-1"><a class="header-anchor" href="#_12-3-1-什么是数据卷" aria-hidden="true">#</a> 12.3.1.什么是数据卷</h3><p>**数据卷（volume）**是一个虚拟目录，指向宿主机文件系统中的某个目录。</p><p><img src="https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/image-20210731173541846.png" alt="image-20210731173541846"></p><p>一旦完成数据卷挂载，对容器的一切操作都会作用在数据卷对应的宿主机目录了。</p><p>这样，我们操作宿主机的/var/lib/docker/volumes/html 目录，就等于操作容器内的/usr/share/nginx/html 目录了</p><h3 id="_12-3-2-数据集操作命令" tabindex="-1"><a class="header-anchor" href="#_12-3-2-数据集操作命令" aria-hidden="true">#</a> 12.3.2.数据集操作命令</h3><p>数据卷操作的基本语法如下：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> volume <span class="token punctuation">[</span>COMMAND<span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>docker volume 命令是数据卷操作，根据命令后跟随的 command 来确定下一步的操作：</p><ul><li>create 创建一个 volume</li><li>inspect 显示一个或多个 volume 的信息</li><li>ls 列出所有的 volume</li><li>prune 删除未使用的 volume</li><li>rm 删除一个或多个指定的 volume</li></ul><h3 id="_12-3-3-创建和查看数据卷" tabindex="-1"><a class="header-anchor" href="#_12-3-3-创建和查看数据卷" aria-hidden="true">#</a> 12.3.3.创建和查看数据卷</h3><p><strong>需求</strong>：创建一个数据卷，并查看数据卷在宿主机的目录位置</p><p>① 创建数据卷</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> volume create html
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>② 查看所有数据</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> volume <span class="token function">ls</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>结果：</p><p><img src="https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/image-20210731173746910.png" alt="image-20210731173746910"></p><p>③ 查看数据卷详细信息卷</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> volume inspect html
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>结果：</p><p><img src="https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/image-20210731173809877.png" alt="image-20210731173809877"></p><p>可以看到，我们创建的 html 这个数据卷关联的宿主机目录为<code>/var/lib/docker/volumes/html/_data</code>目录。</p><p><strong>小结</strong>：</p><p>数据卷的作用：</p><ul><li>将容器与数据分离，解耦合，方便操作容器内数据，保证数据安全</li></ul><p>数据卷操作：</p><ul><li>docker volume create：创建数据卷</li><li>docker volume ls：查看所有数据卷</li><li>docker volume inspect：查看数据卷详细信息，包括关联的宿主机目录位置</li><li>docker volume rm：删除指定数据卷</li><li>docker volume prune：删除所有未使用的数据卷</li></ul><h3 id="_12-3-4-挂载数据卷" tabindex="-1"><a class="header-anchor" href="#_12-3-4-挂载数据卷" aria-hidden="true">#</a> 12.3.4.挂载数据卷</h3><p>我们在创建容器时，可以通过 -v 参数来挂载一个数据卷到某个容器内目录，命令格式如下：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> run <span class="token punctuation">\\</span>
  <span class="token parameter variable">--name</span> nginx <span class="token punctuation">\\</span>
  <span class="token parameter variable">-v</span> html:/root/html <span class="token punctuation">\\</span>
  <span class="token parameter variable">-p</span> <span class="token number">80</span>:80 <span class="token punctuation">\\</span>
  nginx <span class="token punctuation">\\</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里的-v 就是挂载数据卷的命令：</p><ul><li><code>-v html:/root/html</code> ：把 html 数据卷挂载到容器内的/root/html 这个目录中</li></ul><h3 id="_12-3-5-案例-给-nginx-挂载数据卷" tabindex="-1"><a class="header-anchor" href="#_12-3-5-案例-给-nginx-挂载数据卷" aria-hidden="true">#</a> 12.3.5.案例-给 nginx 挂载数据卷</h3><p><strong>需求</strong>：创建一个 nginx 容器，修改容器内的 html 目录内的 index.html 内容</p><p><strong>分析</strong>：上个案例中，我们进入 nginx 容器内部，已经知道 nginx 的 html 目录所在位置/usr/share/nginx/html ，我们需要把这个目录挂载到 html 这个数据卷上，方便操作其中的内容。</p><p><strong>提示</strong>：运行容器时使用 -v 参数挂载数据卷</p><p>步骤：</p><p>① 创建容器并挂载数据卷到容器内的 HTML 目录</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">docker</span> run <span class="token parameter variable">--name</span> mn <span class="token parameter variable">-v</span> html:/usr/share/nginx/html <span class="token parameter variable">-p</span> <span class="token number">80</span>:80 <span class="token parameter variable">-d</span> nginx
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>② 进入 html 数据卷所在位置，并修改 HTML 内容</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 查看html数据卷的位置</span>
<span class="token function">docker</span> volume inspect html
<span class="token comment"># 进入该目录</span>
<span class="token builtin class-name">cd</span> /var/lib/docker/volumes/html/_data
<span class="token comment"># 修改文件</span>
<span class="token function">vi</span> index.html
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_12-3-6-案例-给-mysql-挂载本地目录" tabindex="-1"><a class="header-anchor" href="#_12-3-6-案例-给-mysql-挂载本地目录" aria-hidden="true">#</a> 12.3.6.案例-给 MySQL 挂载本地目录</h3><p>容器不仅仅可以挂载数据卷，也可以直接挂载到宿主机目录上。关联关系如下：</p><ul><li>带数据卷模式：宿主机目录 --&gt; 数据卷 ---&gt; 容器内目录</li><li>直接挂载模式：宿主机目录 ---&gt; 容器内目录</li></ul><p><strong>语法</strong>：</p><p>目录挂载与数据卷挂载的语法是类似的：</p><ul><li>-v [宿主机目录]:[容器内目录]</li><li>-v [宿主机文件]:[容器内文件]</li></ul><p><strong>需求</strong>：创建并运行一个 MySQL 容器，将宿主机目录直接挂载到容器</p><p>实现思路如下：</p><p>1）在将课前资料中的 mysql.tar 文件上传到虚拟机，通过 load 命令加载为镜像</p><p>2）创建目录/tmp/mysql/data</p><p>3）创建目录/tmp/mysql/conf，将课前资料提供的 hmy.cnf 文件上传到/tmp/mysql/conf</p><p>4）去 DockerHub 查阅资料，创建并运行 MySQL 容器，要求：</p><p>① 挂载/tmp/mysql/data 到 mysql 容器内数据存储目录</p><p>② 挂载/tmp/mysql/conf/hmy.cnf 到 mysql 容器的配置文件</p><p>③ 设置 MySQL 密码</p><h3 id="_12-3-7-小结" tabindex="-1"><a class="header-anchor" href="#_12-3-7-小结" aria-hidden="true">#</a> 12.3.7.小结</h3><p>docker run 的命令中通过 -v 参数挂载文件或目录到容器中：</p><ul><li>-v volume 名称:容器内目录</li><li>-v 宿主机文件:容器内文</li><li>-v 宿主机目录:容器内目录</li></ul><p>数据卷挂载与目录直接挂载的</p><ul><li>数据卷挂载耦合度低，由 docker 来管理目录，但是目录较深，不好找</li><li>目录挂载耦合度高，需要我们自己管理目录，不过目录容易寻找查看</li></ul>`,75);function h(v,b){const s=t("ExternalLinkIcon");return r(),p("div",null,[c,a("p",null,[e("1）首先去镜像仓库搜索 nginx 镜像，比如"),a("a",o,[e("DockerHub"),i(s)]),e(":")]),u,a("p",null,[e("在浏览器访问自己的虚拟机地址，例如我的是："),a("a",m,[e("http://192.168.150.101"),i(s)]),e("，即可看到结果：")]),g])}const _=l(d,[["render",h],["__file","12. Docker 基本操作.html.vue"]]);export{_ as default};
