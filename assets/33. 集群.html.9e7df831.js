import{_ as s}from"./_plugin-vue_export-helper.cdc0426e.js";import{o as d,c as g,a as e,d as a,w as t,b as i,e as n,r}from"./app.e5fc3623.js";const h={},o=e("h1",{id:"_33-集群",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#_33-集群","aria-hidden":"true"},"#"),i(" 33. 集群")],-1),c=e("p",null,"单机的 elasticsearch 做数据存储，必然面临两个问题：海量数据存储问题、单点故障问题。",-1),u=e("ul",null,[e("li",null,"海量数据存储问题：将索引库从逻辑上拆分为 N 个分片（shard），存储到多个节点"),e("li",null,"单点故障问题：将分片数据在不同节点备份（replica ）")],-1),m=e("p",null,[e("strong",null,"ES 集群相关概念"),i(":")],-1),_=e("li",null,[e("p",null,"集群（cluster）：一组拥有共同的 cluster name 的 节点。")],-1),f=e("p",null,"解决问题：数据量太大，单点存储量有限的问题。",-1),S=e("p",null,[e("img",{src:"https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/202211091711597.png",alt:"image-20200104124440086"})],-1),v=e("blockquote",null,[e("p",null,"此处，我们把数据分成 3 片：shard0、shard1、shard2")],-1),b=e("li",null,[e("p",null,"主分片（Primary shard）：相对于副本分片的定义。")],-1),j=e("li",null,[e("p",null,"副本分片（Replica shard）每个主分片可以有一个或者多个副本，数据和主分片一样。")],-1),F=n('<p>数据备份可以保证高可用，但是每个分片备份一份，所需要的节点数量就会翻一倍，成本实在是太高了！</p><p>为了在高可用和成本间寻求平衡，我们可以这样做：</p><ul><li>首先对数据分片，存储到不同节点</li><li>然后对每个分片进行备份，放到对方节点，完成互相备份</li></ul><p>这样可以大大减少所需要的服务节点数量，如图，我们以 3 分片，每个分片备份一份为例：</p><p><img src="https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/202211091711066.png" alt="image-20200104124551912"></p><p>现在，每个分片都有 1 个备份，存储在 3 个节点：</p><ul><li>node0：保存了分片 0 和 1</li><li>node1：保存了分片 0 和 2</li><li>node2：保存了分片 1 和 2</li></ul><h2 id="_33-1-搭建-es-集群" tabindex="-1"><a class="header-anchor" href="#_33-1-搭建-es-集群" aria-hidden="true">#</a> 33.1.搭建 ES 集群</h2>',8),x={href:"https://surplusfate.github.io/docs/Spring%E7%B3%BB%E5%88%97/SpringCloud/21.%20%E5%AE%89%E8%A3%85%20es%E3%80%81kibana.html#_21-4-%E9%83%A8%E7%BD%B2-es-%E9%9B%86%E7%BE%A4",target:"_blank",rel:"noopener noreferrer"},E=n('<h2 id="_33-2-集群脑裂问题" tabindex="-1"><a class="header-anchor" href="#_33-2-集群脑裂问题" aria-hidden="true">#</a> 33.2.集群脑裂问题</h2><h3 id="_33-2-1-集群职责划分" tabindex="-1"><a class="header-anchor" href="#_33-2-1-集群职责划分" aria-hidden="true">#</a> 33.2.1.集群职责划分</h3><p>elasticsearch 中集群节点有不同的职责划分：</p><p><img src="https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/202211091711991.png" alt="image-20210723223008967"></p><p>默认情况下，集群中的任何一个节点都同时具备上述四种角色。</p><p>但是真实的集群一定要将集群职责分离：</p><ul><li>master 节点：对 CPU 要求高，但是内存要求第</li><li>data 节点：对 CPU 和内存要求都高</li><li>coordinating 节点：对网络带宽、CPU 要求高</li></ul><p>职责分离可以让我们根据不同节点的需求分配不同的硬件去部署。而且避免业务之间的互相干扰。</p><p>一个典型的 es 集群职责划分如图：</p><p><img src="https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/202211091711606.png" alt="image-20210723223629142"></p><h3 id="_33-2-2-脑裂问题" tabindex="-1"><a class="header-anchor" href="#_33-2-2-脑裂问题" aria-hidden="true">#</a> 33.2.2.脑裂问题</h3><p>脑裂是因为集群中的节点失联导致的。</p><p>例如一个集群中，主节点与其它节点失联：</p><p><img src="https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/202211091711123.png" alt="image-20210723223804995"></p><p>此时，node2 和 node3 认为 node1 宕机，就会重新选主：</p><p><img src="https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/202211091711822.png" alt="image-20210723223845754"></p><p>当 node3 当选后，集群继续对外提供服务，node2 和 node3 自成集群，node1 自成集群，两个集群数据不同步，出现数据差异。</p><p>当网络恢复后，因为集群中有两个 master 节点，集群状态的不一致，出现脑裂的情况：</p><p><img src="https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/202211091712801.png" alt="image-20210723224000555"></p><p>解决脑裂的方案是，要求选票超过 ( eligible 节点数量 + 1 ）/ 2 才能当选为主，因此 eligible 节点数量最好是奇数。对应配置项是 discovery.zen.minimum_master_nodes，在 es7.0 以后，已经成为默认配置，因此一般不会发生脑裂问题</p><p>例如：3 个节点形成的集群，选票必须超过 （3 + 1） / 2 ，也就是 2 票。node3 得到 node2 和 node3 的选票，当选为主。node1 只有自己 1 票，没有当选。集群中依然只有 1 个主节点，没有出现脑裂。</p><h3 id="_33-2-3-小结" tabindex="-1"><a class="header-anchor" href="#_33-2-3-小结" aria-hidden="true">#</a> 33.2.3.小结</h3><p>master eligible 节点的作用是什么？</p><ul><li>参与集群选主</li><li>主节点可以管理集群状态、管理分片信息、处理创建和删除索引库的请求</li></ul><p>data 节点的作用是什么？</p><ul><li>数据的 CRUD</li></ul><p>coordinator 节点的作用是什么？</p><ul><li><p>路由请求到其它节点</p></li><li><p>合并查询到的结果，返回给用户</p></li></ul><h2 id="_33-3-集群分布式存储" tabindex="-1"><a class="header-anchor" href="#_33-3-集群分布式存储" aria-hidden="true">#</a> 33.3.集群分布式存储</h2><p>当新增文档时，应该保存到不同分片，保证数据均衡，那么 coordinating node 如何确定数据该存储到哪个分片呢？</p><h3 id="_33-3-1-分片存储测试" tabindex="-1"><a class="header-anchor" href="#_33-3-1-分片存储测试" aria-hidden="true">#</a> 33.3.1.分片存储测试</h3><p>插入三条数据：</p><p><img src="https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/202211091712965.png" alt="image-20210723225006058"></p><p><img src="https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/202211091712900.png" alt="image-20210723225034637"></p><p><img src="https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/202211091712620.png" alt="image-20210723225112029"></p><p>测试可以看到，三条数据分别在不同分片：</p><p><img src="https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/202211091712190.png" alt="image-20210723225227928"></p><p>结果：</p><p><img src="https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/202211091712516.png" alt="image-20210723225342120"></p><h3 id="_33-3-2-分片存储原理" tabindex="-1"><a class="header-anchor" href="#_33-3-2-分片存储原理" aria-hidden="true">#</a> 33.3.2.分片存储原理</h3><p>elasticsearch 会通过 hash 算法来计算文档应该存储到哪个分片：</p><p><img src="https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/202211091712083.png" alt="image-20210723224354904"></p><p>说明：</p><ul><li>_routing 默认是文档的 id</li><li>算法与分片数量有关，因此索引库一旦创建，分片数量不能修改！</li></ul><p>新增文档的流程如下：</p><p><img src="https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/202211091712444.png" alt="image-20210723225436084"></p><p>解读：</p><ul><li>1）新增一个 id=1 的文档</li><li>2）对 id 做 hash 运算，假如得到的是 2，则应该存储到 shard-2</li><li>3）shard-2 的主分片在 node3 节点，将数据路由到 node3</li><li>4）保存文档</li><li>5）同步给 shard-2 的副本 replica-2，在 node2 节点</li><li>6）返回结果给 coordinating-node 节点</li></ul><h2 id="_33-4-集群分布式查询" tabindex="-1"><a class="header-anchor" href="#_33-4-集群分布式查询" aria-hidden="true">#</a> 33.4.集群分布式查询</h2><p>elasticsearch 的查询分成两个阶段：</p><ul><li><p>scatter phase：分散阶段，coordinating node 会把请求分发到每一个分片</p></li><li><p>gather phase：聚集阶段，coordinating node 汇总 data node 的搜索结果，并处理为最终结果集返回给用户</p></li></ul><p><img src="https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/202211091712016.png" alt="image-20210723225809848"></p><h2 id="_33-5-集群故障转移" tabindex="-1"><a class="header-anchor" href="#_33-5-集群故障转移" aria-hidden="true">#</a> 33.5.集群故障转移</h2><p>集群的 master 节点会监控集群中的节点状态，如果发现有节点宕机，会立即将宕机节点的分片数据迁移到其它节点，确保数据安全，这个叫做故障转移。</p><p>1）例如一个集群结构如图：</p><p><img src="https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/202211091712726.png" alt="image-20210723225945963"></p><p>现在，node1 是主节点，其它两个节点是从节点。</p><p>2）突然，node1 发生了故障：</p><p><img src="https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/202211091712711.png" alt="image-20210723230020574"></p><p>宕机后的第一件事，需要重新选主，例如选中了 node2：</p><p><img src="https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/202211091712542.png" alt="image-20210723230055974"></p><p>node2 成为主节点后，会检测集群监控状态，发现：shard-1、shard-0 没有副本节点。因此需要将 node1 上的数据迁移到 node2、node3：</p><p><img src="https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/202211091712374.png" alt="image-20210723230216642"></p>',63);function B(k,C){const l=r("font"),p=r("ExternalLinkIcon");return d(),g("div",null,[o,c,u,m,e("ul",null,[_,e("li",null,[a(l,{color:"red"},{default:t(()=>[i("节点（node)")]),_:1}),i(" ：集群中的一个 Elasticearch 实例")]),e("li",null,[a(l,{color:"red"},{default:t(()=>[i("分片（shard）")]),_:1}),i("：索引可以被拆分为不同的部分进行存储，称为分片。在集群环境下，一个索引的不同分片可以拆分到不同的节点中"),f,S,v]),b,j]),F,e("p",null,[e("a",x,[i("部署 es 集群"),a(p)])]),E])}const P=s(h,[["render",B],["__file","33. 集群.html.vue"]]);export{P as default};
