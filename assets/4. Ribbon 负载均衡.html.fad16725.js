import{_ as r}from"./_plugin-vue_export-helper.cdc0426e.js";import{o as i,c as l,a as e,b as a,d as t,e as s,r as o}from"./app.b3e56b5b.js";const d={},c=s('<h1 id="_4-ribbon-负载均衡" tabindex="-1"><a class="header-anchor" href="#_4-ribbon-负载均衡" aria-hidden="true">#</a> 4. Ribbon 负载均衡</h1><p>上一节中，我们添加了@LoadBalanced 注解，即可实现负载均衡功能，这是什么原理呢？</p><h2 id="_4-1-负载均衡原理" tabindex="-1"><a class="header-anchor" href="#_4-1-负载均衡原理" aria-hidden="true">#</a> 4.1.负载均衡原理</h2><p>SpringCloud 底层其实是利用了一个名为 Ribbon 的组件，来实现负载均衡功能的。</p><p><img src="https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/image-20210713224517686.png" alt="image-20210713224517686"></p>',5),p={href:"http://userservice/user/1",target:"_blank",rel:"noopener noreferrer"},u={href:"http://localhost:8081",target:"_blank",rel:"noopener noreferrer"},h=s('<h2 id="_4-2-源码跟踪" tabindex="-1"><a class="header-anchor" href="#_4-2-源码跟踪" aria-hidden="true">#</a> 4.2.源码跟踪</h2><p>为什么我们只输入了 service 名称就可以访问了呢？之前还要获取 ip 和端口。</p><p>显然有人帮我们根据 service 名称，获取到了服务实例的 ip 和端口。它就是<code>LoadBalancerInterceptor</code>，这个类会在对 RestTemplate 的请求进行拦截，然后从 Eureka 根据服务 id 获取服务列表，随后利用负载均衡算法得到真实的服务地址信息，替换服务 id。</p><p>我们进行源码跟踪：</p><h3 id="_4-2-1-loadbalancerintercepor" tabindex="-1"><a class="header-anchor" href="#_4-2-1-loadbalancerintercepor" aria-hidden="true">#</a> 4.2.1.LoadBalancerIntercepor</h3><p><img src="https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/1525620483637.png" alt="1525620483637"></p><p>可以看到这里的 intercept 方法，拦截了用户的 HttpRequest 请求，然后做了几件事：</p>',7),g=e("code",null,"request.getURI()",-1),m={href:"http://user-service/user/8",target:"_blank",rel:"noopener noreferrer"},_=e("li",null,[e("code",null,"originalUri.getHost()"),a("：获取 uri 路径的主机名，其实就是服务 id，"),e("code",null,"user-service")],-1),b=e("li",null,[e("code",null,"this.loadBalancer.execute()"),a("：处理服务 id，和用户请求。")],-1),v=s('<p>这里的<code>this.loadBalancer</code>是<code>LoadBalancerClient</code>类型，我们继续跟入。</p><h3 id="_4-2-2-loadbalancerclient" tabindex="-1"><a class="header-anchor" href="#_4-2-2-loadbalancerclient" aria-hidden="true">#</a> 4.2.2.LoadBalancerClient</h3><p>继续跟入 execute 方法：</p><p><img src="https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/1525620787090.png" alt="1525620787090"></p><p>代码是这样的：</p><ul><li>getLoadBalancer(serviceId)：根据服务 id 获取 ILoadBalancer，而 ILoadBalancer 会拿着服务 id 去 eureka 中获取服务列表并保存起来。</li><li>getServer(loadBalancer)：利用内置的负载均衡算法，从服务列表中选择一个。本例中，可以看到获取了 8082 端口的服务</li></ul><p>放行后，再次访问并跟踪，发现获取的是 8081：</p><p><img src="https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/1525620835911.png" alt="1525620835911"></p><p>果然实现了负载均衡。</p><h3 id="_4-2-3-负载均衡策略-irule" tabindex="-1"><a class="header-anchor" href="#_4-2-3-负载均衡策略-irule" aria-hidden="true">#</a> 4.2.3.负载均衡策略 IRule</h3><p>在刚才的代码中，可以看到获取服务使通过一个<code>getServer</code>方法来做负载均衡:</p><p><img src="https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/1525620835911.png" alt="1525620835911"></p><p>我们继续跟入：</p><p><img src="https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/1544361421671.png" alt="1544361421671"></p><p>继续跟踪源码 chooseServer 方法，发现这么一段代码：</p><p><img src="https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/1525622652849.png" alt="1525622652849"></p><p>我们看看这个 rule 是谁：</p><p><img src="https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/1525622699666.png" alt="1525622699666"></p><p>这里的 rule 默认值是一个<code>RoundRobinRule</code>，看类的介绍：</p><p><img src="https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/1525622754316.png" alt="1525622754316"></p><p>这不就是轮询的意思嘛。</p><p>到这里，整个负载均衡的流程我们就清楚了。</p><h3 id="_4-2-4-总结" tabindex="-1"><a class="header-anchor" href="#_4-2-4-总结" aria-hidden="true">#</a> 4.2.4.总结</h3><p>SpringCloudRibbon 的底层采用了一个拦截器，拦截了 RestTemplate 发出的请求，对地址做了修改。用一幅图来总结一下：</p><p><img src="https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/image-20210713224724673.png" alt="image-20210713224724673"></p><p>基本流程如下：</p>',26),k={href:"http://userservice/user/1",target:"_blank",rel:"noopener noreferrer"},R=e("li",null,"RibbonLoadBalancerClient 会从请求 url 中获取服务名称，也就是 user-service",-1),f=e("li",null,"DynamicServerListLoadBalancer 根据 user-service 到 eureka 拉取服务列表",-1),x=e("li",null,"eureka 返回列表，localhost:8081、localhost:8082",-1),y=e("li",null,"IRule 利用内置负载均衡规则，从列表中选择一个，例如 localhost:8081",-1),B={href:"http://localhost:8081/user/1",target:"_blank",rel:"noopener noreferrer"},S=s(`<h2 id="_4-3-负载均衡策略" tabindex="-1"><a class="header-anchor" href="#_4-3-负载均衡策略" aria-hidden="true">#</a> 4.3.负载均衡策略</h2><h3 id="_4-3-1-负载均衡策略" tabindex="-1"><a class="header-anchor" href="#_4-3-1-负载均衡策略" aria-hidden="true">#</a> 4.3.1.负载均衡策略</h3><p>负载均衡的规则都定义在 IRule 接口中，而 IRule 有很多不同的实现类：</p><p><img src="https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/image-20210713225653000.png" alt="image-20210713225653000"></p><p>不同规则的含义如下：</p><table><thead><tr><th><strong>内置负载均衡规则类</strong></th><th><strong>规则描述</strong></th></tr></thead><tbody><tr><td>RoundRobinRule</td><td>简单轮询服务列表来选择服务器。它是 Ribbon 默认的负载均衡规则。</td></tr><tr><td>AvailabilityFilteringRule</td><td>对以下两种服务器进行忽略： （1）在默认情况下，这台服务器如果 3 次连接失败，这台服务器就会被设置为“短路”状态。短路状态将持续 30 秒，如果再次连接失败，短路的持续时间就会几何级地增加。 （2）并发数过高的服务器。如果一个服务器的并发连接数过高，配置了 AvailabilityFilteringRule 规则的客户端也会将其忽略。并发连接数的上限，可以由客户端的&lt;clientName&gt;.&lt;clientConfigNameSpace&gt;.ActiveConnectionsLimit 属性进行配置。</td></tr><tr><td>WeightedResponseTimeRule</td><td>为每一个服务器赋予一个权重值。服务器响应时间越长，这个服务器的权重就越小。这个规则会随机选择服务器，这个权重值会影响服务器的选择。</td></tr><tr><td><strong>ZoneAvoidanceRule</strong></td><td>以区域可用的服务器为基础进行服务器的选择。使用 Zone 对服务器进行分类，这个 Zone 可以理解为一个机房、一个机架等。而后再对 Zone 内的多个服务做轮询。</td></tr><tr><td>BestAvailableRule</td><td>忽略那些短路的服务器，并选择并发数较低的服务器。</td></tr><tr><td>RandomRule</td><td>随机选择一个可用的服务器。</td></tr><tr><td>RetryRule</td><td>重试机制的选择逻辑</td></tr></tbody></table><p>默认的实现就是 ZoneAvoidanceRule，是一种轮询方案</p><h3 id="_4-3-2-自定义负载均衡策略" tabindex="-1"><a class="header-anchor" href="#_4-3-2-自定义负载均衡策略" aria-hidden="true">#</a> 4.3.2.自定义负载均衡策略</h3><p>通过定义 IRule 实现可以修改负载均衡规则，有两种方式：</p><ol><li><p>代码方式：在 order-service 中的 OrderApplication 类中，定义一个新的 IRule：</p><div class="language-java line-numbers-mode" data-ext="java"><pre class="language-java"><code><span class="token annotation punctuation">@Bean</span>
<span class="token keyword">public</span> <span class="token class-name">IRule</span> <span class="token function">randomRule</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">RandomRule</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>配置文件方式：在 order-service 的 application.yml 文件中，添加新的配置也可以修改规则：</p></li></ol><div class="language-yaml line-numbers-mode" data-ext="yml"><pre class="language-yaml"><code><span class="token key atrule">userservice</span><span class="token punctuation">:</span> <span class="token comment"># 给某个微服务配置负载均衡规则，这里是userservice服务</span>
  <span class="token key atrule">ribbon</span><span class="token punctuation">:</span>
    <span class="token key atrule">NFLoadBalancerRuleClassName</span><span class="token punctuation">:</span> com.netflix.loadbalancer.RandomRule <span class="token comment"># 负载均衡规则</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p><strong>注意</strong>，一般用默认的负载均衡规则，不做修改。</p></blockquote><h2 id="_4-4-饥饿加载" tabindex="-1"><a class="header-anchor" href="#_4-4-饥饿加载" aria-hidden="true">#</a> 4.4.饥饿加载</h2><p>Ribbon 默认是采用懒加载，即第一次访问时才会去创建 LoadBalanceClient，请求时间会很长。</p><p>而饥饿加载则会在项目启动时创建，降低第一次访问的耗时，通过下面配置开启饥饿加载：</p><div class="language-yaml line-numbers-mode" data-ext="yml"><pre class="language-yaml"><code><span class="token key atrule">ribbon</span><span class="token punctuation">:</span>
  <span class="token key atrule">eager-load</span><span class="token punctuation">:</span>
    <span class="token key atrule">enabled</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>
    <span class="token key atrule">clients</span><span class="token punctuation">:</span> userservice
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,16);function L(I,j){const n=o("ExternalLinkIcon");return i(),l("div",null,[c,e("p",null,[a("那么我们发出的请求明明是 "),e("a",p,[a("http://userservice/user/1"),t(n)]),a("，怎么变成了 "),e("a",u,[a("http://localhost:8081"),t(n)]),a(" 的呢？")]),h,e("ul",null,[e("li",null,[g,a("：获取请求 uri，本例中就是 "),e("a",m,[a("http://user-service/user/8"),t(n)])]),_,b]),v,e("ul",null,[e("li",null,[a("拦截我们的 RestTemplate 请求 "),e("a",k,[a("http://userservice/user/1"),t(n)])]),R,f,x,y,e("li",null,[a("RibbonLoadBalancerClient 修改请求地址，用 localhost:8081 替代 userservice，得到 "),e("a",B,[a("http://localhost:8081/user/1"),t(n)]),a("，发起真实请求")])]),S])}const N=r(d,[["render",L],["__file","4. Ribbon 负载均衡.html.vue"]]);export{N as default};
