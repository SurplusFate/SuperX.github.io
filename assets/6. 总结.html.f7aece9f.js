import{_ as e}from"./_plugin-vue_export-helper.cdc0426e.js";import{o,c as p,e as d}from"./app.1407a880.js";const c={},a=d('<h1 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h1><h2 id="注解" tabindex="-1"><a class="header-anchor" href="#注解" aria-hidden="true">#</a> 注解</h2><p>Spring + SpringMVC + SpringBoot</p><h3 id="创建对象的" tabindex="-1"><a class="header-anchor" href="#创建对象的" aria-hidden="true">#</a> 创建对象的</h3><p><code>@Controller</code></p><p>放在类的上面，创建控制器对象，注入到容器中</p><p><code>@RestController</code></p><p>放在类的上面，创建控制器对象，注入到容器中。</p><p>作用：复合注解 <code>@Controller</code> , <code>@ResponseBody</code>, 使用这个注解类的，里面的控制器方法的返回值都是数据</p><p><code>@Service</code></p><p>放在业务层的实现类上面，创建 service 对象，注入到容器</p><p><code>@Repository</code></p><p>放在 dao 层的实现类上面，创建 dao 对象，放入到容器。 没有使用这个注解，是因为现在使用 MyBatis 框 架， dao 对象是 MyBatis 通过代理生成的。 不需要使用<code>@Repository</code>、 所以没有使用。</p><p><code>@Component</code></p><p>放在类的上面，创建此类的对象，放入到容器中。</p><h3 id="赋值的" tabindex="-1"><a class="header-anchor" href="#赋值的" aria-hidden="true">#</a> 赋值的</h3><p><code>@Value</code></p><p>简单类型的赋值， 例如 在属性的上面使用 <code>@Value(&quot;李四&quot;) private String name</code></p><p>还可以使用 <code>@Value</code>, 获取配置文件者的数据（properties 或 yml）。</p><p><code>@Value(&quot;${server.port}&quot;) private Integer port</code></p><p><code>@Autowired</code></p><p>引用类型赋值自动注入的，支持 byName, byType. 默认是 byType 。 放在属性的上面，也可以放在构造方法的上面。 推荐是放在构造方法的上面</p><p><code>@Qualifer</code></p><p>给引用类型赋值，使用 byName 方式。 <code>@Autowird</code>, <code>@Qualifer</code>都是 Spring 框架提供的。</p><p><code>@Resource</code></p><p>来自 jdk 中的定义， javax.annotation。 实现引用类型的自动注入， 支持 byName, byType. 默认是 byName, 如果 byName 失败， 再使用 byType 注入。 在属性上面使用</p><h3 id="其他" tabindex="-1"><a class="header-anchor" href="#其他" aria-hidden="true">#</a> 其他</h3><p><code>@Configuration</code></p><p>放在类的上面，表示这是个配置类，相当于 xml 配置文件</p><p><code>@Bean</code></p><p>放在方法的上面， 把方法的返回值对象，注入到 spring 容器中。</p><p><code>@ImportResource</code></p><p>加载其他的 xml 配置文件， 把文件中的对象注入到 spring 容器中</p><p><code>@PropertySource</code></p><p>读取其他的 properties 属性配置文件</p><p><code>@ComponentScan</code></p><p>扫描器 ，指定包名，扫描注解的</p><p><code>@ResponseBody</code></p><p>放在方法的上面，表示方法的返回值是数据， 不是视图</p><p><code>@RequestBody</code></p><p>把请求体中的数据，读取出来， 转为 java 对象使用。</p><p><code>@ControllerAdvice</code></p><p>控制器增强， 放在类的上面， 表示此类提供了方法，可以对 controller 增强功能。</p><p><code>@ExceptionHandle</code></p><p>处理异常的，放在方法的上面</p><p><code>@Transcational</code></p><p>处理事务的， 放在 service 实现类的 public 方法上面， 表示此方法有事务</p><h3 id="springboot-中使用的注解" tabindex="-1"><a class="header-anchor" href="#springboot-中使用的注解" aria-hidden="true">#</a> SpringBoot 中使用的注解</h3><p><code>@SpringBootApplication</code></p><p>放在启动类上面， 包含了<code>@SpringBootConfiguration</code>, <code>@EnableAutoConfiguration</code>, <code>@ComponentScan</code></p><h3 id="mybatis-相关的注解" tabindex="-1"><a class="header-anchor" href="#mybatis-相关的注解" aria-hidden="true">#</a> MyBatis 相关的注解</h3><p><code>@Mapper</code></p><p>放在类的上面 ， 让 MyBatis 找到接口， 创建他的代理对象</p><p><code>@MapperScan</code></p><p>放在主类的上面 ， 指定扫描的包， 把这个包中的所有接口都创建代理对象。 对象注入到容器中 <code>@Param</code></p><p>放在 dao 接口的方法的形参前面， 作为命名参数使用的。</p><h3 id="dubbo-注解" tabindex="-1"><a class="header-anchor" href="#dubbo-注解" aria-hidden="true">#</a> Dubbo 注解</h3><p><code>@DubboService</code></p><p>在提供者端使用的，暴露服务的， 放在接口的实现类上面</p><p><code>@DubboReference</code></p><p>在消费者端使用的， 引用远程服务， 放在属性上面使用。 <code>@EnableDubbo</code></p><p>放在主类上面， 表示当前引用启用 Dubbo 功能。</p>',62),r=[a];function i(t,n){return o(),p("div",null,r)}const l=e(c,[["render",i],["__file","6. 总结.html.vue"]]);export{l as default};
