---
icon: note
date: 2022-06-06
order: 4
category:
- java
---

# 数据类型

Java是一种强类型语言。这就意味着必须为每一个变量声明一种类型。在Java中，一共有8种基本类型（primitive type），其中有4种整型、2种浮点类型、1种用于表示Unicode编码的字符单元的字符类型char（请参见论述char类型的章节）和1种用于表示真值的boolean类型。

## 分类

Java语言支持的类型分为两类：基本类型（Primitive Type）和引用类型（Reference Type）。

1. 基本类型，四大类八小种：

   整数型：整型用于表示没有小数部分的数值，它允许是负数。Java提供了4种整型：byte、short、int、long

   浮点型：浮点类型用于表示有小数部分的数值。在Java中有两种浮点类型：float、double

   布尔型：boolean（布尔）类型有两个值：false和true，用来判定逻辑条件。整型值和布尔值之间不能进行相互转换。

   字符型（char型）：char类型原本用于表示单个字符。不过，现在情况已经有所变化。如今，有些Unicode字符可以用一个char值描述，另外一些Unicode字符则需要两个char值。

| 类型名称     | 关键字  | 占用内存 | 取值范围                                   | 缺省默认值 |
| ------------ | ------- | -------- | ------------------------------------------ | ---------- |
| 字节型       | byte    | 1  字节  | -128~127                                   | 0          |
| 短整型       | short   | 2  字节  | -32768~32767                               | 0          |
| 整型         | int     | 4  字节  | -2147483648~2147483647                     | 0          |
| 长整型       | long    | 8  字节  | -9223372036854775808L~9223372036854775807L | 0L         |
| 单精度浮点型 | float   | 4  字节  | +/-3.4E+38F（6~7 个有效位）                | 0.0f       |
| 双精度浮点型 | double  | 8  字节  | +/-1.8E+308  (15 个有效位）                | 0.0        |
| 字符型       | char    | 2  字节  | ISO  单一字符集                            | '\u0000'   |
| 布尔型       | boolean | 1  字节  | true  或 false                             | false      |

2. 引用类型：
   引用类型包括类、接口和数组类型，还有一种特殊的null类型。所谓引用数据类型就是对一个对象的引用，对象包括实例和数组两种。

   空类型（null type）就是null值的类型，这种类型没有名称。因为null类型没有名称，所以不可能声明一个null类型的变量或者转换到null类型。空引用（null）是null类型变量唯一的值。空引用（null）可以转换为任何引用类型。

   在实际开发中，程序员可以忽略null类型，假定null只是引用类型的一个特殊直接量。

   ::: tip

   空引用（null）只能被转换成引用类型，不能转换成基本类型，因此不要把一个null值赋给基本数据类型的变量。
   
   :::
   
   前期最常见的引用类型：字符串类型：String

## 基本数据类型

### 整数型

int是最常用的整数类型，因此在通常情况下，一个**Java整数常量默认就是int类型**。除此之外，有如下两种情形必须指出。

1. 如果直接将一个较小的整数常量（在byte或short类型的表数范围内）赋给一个byte或short变量，系统会自动把这个整数常量当成byte或者short类型来处理。

   ![image-20220602212207681](https://fastly.jsdelivr.net/gh/SurplusFate/guide_img@main/img/202206022122729.png)

2. 如果使用一个巨大的整数常量（超出了int类型的表数范围）时，Java不会自动把这个整数常量当成long类型来处理。如果希望系统把一个整数常量当成long类型来处理，应在这个整数常量后增加l或者L作为后缀。通常推荐使用L，因为字母l很容易跟数字1搞混。

   ![image-20220602211756700](https://fastly.jsdelivr.net/gh/SurplusFate/guide_img@main/img/202206071631637.png)

从Java 7开始，加上前缀0b或0B就可以写二进制数。例如，0b1001就是9。另外，同样是从Java 7开始，还可以为数字字面量加下划线，如用1_000_000（或0b1111_0100_0010_0100_0000）表示一百万。这些下划线只是为了让人更易读。Java编译器会去除这些下划线。

![image-20220602212022231](https://fastly.jsdelivr.net/gh/SurplusFate/guide_img@main/img/202206071631599.png)

::: info

在C和C++中，int和long等类型的大小与目标平台相关。在8086这样的16位处理器上整型数值占2字节；不过，在32位处理器（比如Pentium或SPARC）上，整型数值则为4字节。类似地，在32位处理器上long值为4字节，在64位处理器上则为8字节。由于存在这些差别，这对编写跨平台程序带来了很大难度。在Java中，所有的数值类型所占据的字节数量与平台无关。

注意，Java没有任何无符号（unsigned）形式的int、long、short或byte类型。

:::

### 浮点型

double表示这种类型的数值精度是float类型的两倍（有人称之为双精度数值）。绝大部分应用程序都采用double类型。在很多情况下，float类型的精度很难满足需求。实际上，只有很少的情况适合使用float类型，例如，需要单精度数据的库，或者需要存储大量数据。

float类型的数值有一个后缀F或f（例如，3.14F）。没有后缀F的浮点数值（如3.14）默认为double类型。当然，也可以在浮点数值后面添加后缀D或d（例如，3.14D）。

::: info

可以使用十六进制表示浮点数值。例如，0.125=2⁻³可以表示成0x1.0p-3。在十六进制表示法中，使用p表示指数，而不是e。注意，尾数采用十六进制，指数采用十进制。指数的基数是2，而不是10。

:::

所有的浮点数值计算都遵循IEEE 754规范。具体来说，下面是用于表示溢出和出错情况的三个特殊的浮点数值：

● 正无穷大

● 负无穷大

● NaN（不是一个数字）

例如，一个正整数除以0的结果为正无穷大。计算0/0或者负数的平方根结果为NaN。

::: tip

常量Double.POSITIVE_INFINITY、Double.NEGATIVE_INFINITY和Double.NaN（以及相应的Float类型的常量）分别表示这三个特殊的值，但在实际应用中很少遇到。特别要说明的是，不能这样检测一个特定值是否等于Double.NaN：

![image-20220601120133047](https://fastly.jsdelivr.net/gh/SurplusFate/guide_img@main/img/202206011201132.png)

所有“非数值”的值都认为是不相同的。然而，可以使用Double.isNaN方法：

![image-20220608191044077](https://fastly.jsdelivr.net/gh/SurplusFate/guide_img@main/img/202206081910122.png)

:::

## 使用

**变量三要素**

1. 数据类型
2. 变量名
3. 值

数据类型决定空间大小，变量名方便访问，值是变量保存的数据。

**变量的分类**

1. 局部变量
   在方法体中声明的变量，局部变量没有默认值。
2. 成员变量
   在方法体外,类体内声明的变量，成员变量有默认值。
3. 静态变量
   有static关键字修饰的为静态变量

> 变量的有效范围：作用域，出了大括号就不认识了。

**值**

在java语言中“数据”被称为字面量，如：10、1.23、true、false、'a'、"abc"。

“值”的分类：
整数型：1、2、3
浮点型：1.2、3、5
布尔型：true、false
字符型：'a'、'人'
字符串型："abc"、中国"

**声明与赋值**

声明变量的语法非常简单，只要指定变量的类型和变量名即可，如下所示：

``type varName``

例如：``int i``；

> 同一个作用域中变量名不能重名。

变量还可能使用其他修饰符。但不管是哪种变量，定义变量至少需要指定变量类型和变量名两个部分。定义变量时的变量类型可以是Java语言支持的所有类型。

可以先声明后赋值，也可以在声明的同时进行赋值：

![image-20220602211355119](https://fastly.jsdelivr.net/gh/SurplusFate/guide_img@main/img/202206071631799.png)



1. 注意事项

   在任何情况下，整数型的“字面量”默认被当做int处理。

   当这个整数型字面量没有超出byte、short、char取值范围，那么这个整数型字面量可以直接赋值给byte、short、char类型的变量。

   整数可以直接赋值给char，会自动转换成char字符类型

   byte、short、char混合运算
   			byte、short、char做混合运算的时候,各自先转换成int再运算

多种数据类型做混合运算

​		多种数据在做混合运算的时候，最终的结果是类型“最大容量”对应的类型，byte+short+char 例外

基本数据类型转换规则

​		boolean不能参与类型转换,其它都行

​		没有超出byte、short、char 的范围，整数可以直接赋值

自动转换类型
		小转大
		byte<short(char)<int<long<float<double
强制转换类型
		大转小 需要加强制类型转换符

byte,short,char做混合运算的时候,各自先转换成int再运算

多种数据在做混合运算的时候,最终的结果是类型"最大容量"对应的类型

运算符
	算术运算符
		算术运算符用在数学表达式中，它们的作用和在数学中的作用一样。下表列出了所有的算术运算符。假设整数变量A的值为10，变量B的值为20：
		+	加法 - 相加运算符两侧的值	A + B等于30
		-	减法 - 左操作数减去右操作数	A – B等于-10
		*	乘法 - 相乘操作符两侧的值	A * B等于200
		/	除法 - 左操作数除以右操作数	B / A等于2
		％	取模 - 左操作数除以右操作数的余数	B%A等于0
		++	自增 - 操作数的值增加1	B++ 或 ++B 等于 21
		--	自减 - 操作数的值减少1	B-- 或 --B 等于 19
	“+”
		加法运算
		字符串连接运算
	自增自减运算符
		++出现在变量后，先赋值再自加
		++出现在变量前，先自加再赋值
	关系运算符
		假设整数变量A的值为10，变量B的值为20：
		==	检查如果两个操作数的值是否相等，如果相等则条件为真。	（A == B）为假(非真)。
		!=	检查如果两个操作数的值是否相等，如果值不相等则条件为真。	(A != B) 为真。
		> ​	检查左操作数的值是否大于右操作数的值，如果是那么条件为真。	（A> B）非真。
		< 	检查左操作数的值是否小于右操作数的值，如果是那么条件为真。	（A <B）为真。
		> =	检查左操作数的值是否大于或等于右操作数的值，如果是那么条件为真。	（A> = B）为假。
		<=	检查左操作数的值是否小于或等于右操作数的值，如果是那么条件为真。	（A <= B）为真。
	位运算符
		位运算符作用在所有的位上，并且按位运算。
假设整数变量 A 的值为 60 和变量 B 的值为 13：
		＆	如果相对应位都是1，则结果为1，否则为0	（A＆B），得到12，即0000 1100
		|	如果相对应位都是 0，则结果为 0，否则为 1	（A | B）得到61，即 0011 1101
		^	如果相对应位值相同，则结果为0，否则为1	（A ^ B）得到49，即 0011 0001
		〜	按位取反运算符翻转操作数的每一位，即0变成1，1变成0。	（〜A）得到-61，即1100 0011
		<< 	按位左移运算符。左操作数按位左移右操作数指定的位数。	A << 2得到240，即 1111 0000
		>
		>> ​	按位右移运算符。左操作数按位右移右操作数指定的位数。	A >> 2得到15即 1111
		>> ​	按位右移补零操作符。左操作数的值按右操作数指定的位数右移，移动得到的空位以零填充。	A>>>2得到15即0000 1111
		Java定义了位运算符，应用于整数类型(int)，长整型(long)，短整型(short)，字符型(char)，和字节型(byte)等类型。
			实例代码
	Test.java
		逻辑运算符
		逻辑运算符要求两边的算子都是布尔类型，并且逻辑运算符最终的运算结果也是一个布尔类型
			短路逻辑判断运算符
			假设布尔变量A为真，变量B为假
			&&	称为逻辑与运算符。当且仅当两个操作数都为真，条件才为真。	（A && B）为假。
			| |	称为逻辑或操作符。如果任何两个操作数任何一个为真，条件为真。	（A | | B）为真。
		！	称为逻辑非运算符。用来反转操作数的逻辑状态。如果条件为true，则逻辑非运算符将得到false。	！（A && B）为真。
			逻辑判断运算符
			&	逻辑与  
			|  	逻辑或
		！	逻辑非
			短路判断与逻辑判断的区别
逻辑判断全部走一遍
短路判断有结果就停
第一个表达式执行结果为true，会发生短路或
		第一个表达式执行结果为false，会发生短路与
			实例代码
	Test02.java
		赋值运算符
		不会改变运算结果类型
		例如: x += 1等同于x=(x的数据类型)(x + 1)
		=	简单的赋值运算符，将右操作数的值赋给左侧操作数	C = A + B将把A + B得到的值赋给C
		+ =	加和赋值操作符，它把左操作数和右操作数相加赋值给左操作数	C + = A等价于C = C(C的数据类型) + A
		- =	减和赋值操作符，它把左操作数和右操作数相减赋值给左操作数	C - = A等价于C = C(C的数据类型) - A
		* =	乘和赋值操作符，它把左操作数和右操作数相乘赋值给左操作数	C * = A等价于C = C(C的数据类型) * A
		/ =	除和赋值操作符，它把左操作数和右操作数相除赋值给左操作数	C / = A，C 与 A 同类型时等价于 C = C(C的数据类型) / A
		(％)=	取模和赋值操作符，它把左操作数和右操作数取模后赋值给左操作数	C％= A等价于C = C(C的数据类型) ％ A
		><< =	左移位赋值运算符	C << = 2等价于C = C << 2
		> =	右移位赋值运算符	C >> = 2等价于C = C >> 2
		＆=	按位与赋值运算符	C＆= 2等价于C = C(C的数据类型)＆2
		^ =	按位异或赋值操作符	C ^ = 2等价于C = C(C的数据类型) ^ 2
	| =	按位或赋值操作符	C | = 2等价于C = C(C的数据类型) | 2
		三目运算符
语法格式:
			布尔表达式 ? 表达式1 : 表达式2
执行原理:
如果布尔表达式结果为true,则执行表达式1
			如果布尔表达式结果为false,则执行表达式2
	boolean sex = false;
char c = sex ？'男':'女';
System.out.println(sex);
	输出结果为女
		instanceof 运算符
		该运算符用于操作对象实例，检查该对象是否是一个特定类型（类类型或接口类型）。
			instanceof运算符使用格式：
		(引用 instanceof 类型)
		instanceof运算符的2运算结果只能是:true/false
		instanceof可以在运行阶段动态判断引用指向的对象的类型
c是一个引用,c变量保存了内存地址指向堆中的对象
	假设:(c instanceof Cat)为true表示:
c引用指向的堆内存中的java对象是一个Cat
	假设(c instanceof Cat)为false表示:
		c引用指向的堆内存中的java对象不是一个Cat
		在任何时候对类型进行向下转型时都使用instanceof进行判断(java规范)
			实例
			Test03.java

控制语句
	选择语句:
也叫分支语句
		if语句
			在任何情况下只能有一个分支执行,不可能存在2个或者多个分支执行,if语句中只要有1个分支执行,整个if语句就结束了
			else必须跟if
		switch语句
			switch语句执行原理：
				switch后面的小括号当中的“数据”和case后面的“数据”进行一一匹配，匹配成功分支执行。按照顺序结构依次匹配
匹配成功的分支执行，分支当中最后有“break”语句的话，整个switch语句中止。
如果没有“break”语句，直接进入下一个分支执行，不进行匹配（case穿透）
当所有分支都匹配失败，此时如果有default,则执行default语句
switch和case后面只能是int或者String类型的数据,不能是变量,可以是枚举类型
				byte，short，char写进去会自动转换成int
			一个比较完整的switch语句编写
switch（int或String类型的字面值或变量）{
   case int或String类型的字面值或变量：
         java语句；
······
   break；
   case int或String类型的字面值或变量：
         java语句；
······
   break；
······
default：
    java语句；
······
}
				case合并
int i = 1；
switch（i）{
   case 1：case 2：case 3；
     System.out.println(???);
} 
i可以等于1/2/3
			无break会出现case穿透现象
	循环语句:
		for循环
			for语句语法结构
for（初始化表达式；布尔表达式；更新表达式）{
   循环体
}
				循环体内定义的变量在main方法中是无法访问的，出了循环体就释放内存
main方法中定义的"i"变量只要main方法没有结束就可以用
			for循环执行原理
				初始化表达式、布尔表达式、更新表达式都不是必须的！两个分号是必须的
初始化表达式最先执行，且只执行一次
判断布尔表达式结果是true还是false
true:
执行循环体
执行更新表达式
false:
结束for循环
		while循环
			while（布尔表达式）{
循环体：
}
			while循环执行原理
				判断布尔表达式
true:
执行循环体

判断布尔表达式
false:
循环结束
		do...while...循环
			do…while循环和while循环相似
			不同的是,即使不满足条件,do…while循环至少会执行一次。
	转向语句
		break语句
			break是java语言中的关键字，被翻译为“中断/折断”
			break语句可以使用在switch语句中用来终止switch语句
			也可以使用在循环语句中终止循环的执行
			break默认情况下中断最近的循环
				小插曲，给for循环起名,break不通常的情况
for1:for()
   for2:for()
   break for1;
		continue语句
			continue表示：继续/go on/下一个
			主要出现在循环语句中控制循环的执行
			break表示循环不执行，continue表示跳过本次循环,下一次循环继续执行
		return语句
			带有return关键字的java语句只要执行，当前方法立即终止
				在“同一个作用域”当中，return语句下面不能编写任何代码，因为这些代码永远都执行不到，编译报错。
	所有控制语句都可以互相嵌套

方法
	什么是方法？
		方法就是一段代码片段，并且这段代码片段可以完成某个特定的功能，可以被重复使用
方法定义在类体当中，一个类当中可以定义多个方法，方法编写的位置没有先后顺序，可以随意。
方法体中不能再定义方法！
方法体当中的代码遵守自上而下的顺序依次执行
	方法的定义
		语法结构：
[修饰符列表] 返回值类型 方法名(形式参数列表){
	方法体;
}
			修饰符列表：可选项，不必须。
	返回值类型
		什么是返回值
			一个方法是可以完成某个特定功能的，这个功能结束之后大多数都是需要返回最终执行结果的，执行结果可能是一个具体存在的数据，而这个具体存在的数据就是返回值。
				返回值是一个具体存在的数据，数据都是有类型的，此处需要指定的是返回值的具体类型
		返回值类型都可以指定哪些类型呢？
			java任意一种类型都可以，包括基本数据类型和所有的引用数据类型
也可能这个方法执行结束后不返回任何数据，java中规定，当一个方法执行结束后不返回任何数据的话，返回值类型位置必须编写void关键字
				返回值类型若不是void，表示这个方法执行结束后必须返回一个具体的数值，当方法执行结束后没有返回任何数据则编译器报错，如何返回数值？-->“return 值”，并要求“值”的数据类型必须和“方法的返回值类型”一致。不然编译器报错。
返回值类型是void的时候，在方法体当中不能编写“return 值；”但可以编写“return”
只要带有return关键字的语句执行，return语句所在的方法就结束
		返回值类型不是void的时候
			要求方法必须百分百执行“return 值；”这样的语句来完成值的返回。没有这个语句编译器会报错。
			一个方法有返回值的时候，当我们调用这个方法的时候，方法返回了一个值，大部分情况下我们都是选择接收的。
		深入return语句
			带有return关键字的java语句只要执行，当前方法立即终止
				在“同一个作用域”当中，return语句下面不能编写任何代码，因为这些代码永远都执行不到，编译报错。
	方法名
		合法标识符
最好见名知意
最好是动词
首字母小写，后面每个单词首字母大写
	参数
		形式参数列表：形参
			形参是局部变量
个数可以是0~n个
多个形参之间用“，”隔开
形参起决定性作用的是形参的数据类型，形参的名字就是局部变量的名字。
		方法在调用的时候，实际给这个方法传递的真实数据为实际参数，简称实参
			实参列表和形参列表必须满足：
数量相同
类型对应相同
	方法体
		方法体必须由大括号括起来，方法体当中的代码有顺序，遵循自上而下·的顺序依次执行，并且方法体由java语句构成，每一个java语句以“；”结尾
	方法怎么调用？
		方法只定义不去调用时不会执行
语法规则：【方法的修饰符列表当中有static】
类名.方法名（实参列表）；这是一条java语句
有时候“类名”可以省略不写，“类名”省略之后，默认从当前类中找“类名”方法
	JVM内存结构
		方法在执行过程当中，在JVM中的内存是如何分配的？内存如何变化？
			方法只定义不调用，不会执行，并且在JVM中也不会给该方法分配“运行所属”的内存空间。只有在调用这个方法的时候，才会动态的给这个方法分配所属的内存空间。
			 在JVM内存划分上有这样三块主要的内存空间：
				方法区内存
堆内存
栈内存
					

						▪ 关于“栈”数据结构：

▪ 栈：stack，是一种数据结构
▪ 数据结构反应的是数据的储存形态
▪ 数据结构是独立的学科，不属于任何编程语言的范畴，但在大多数编程语言当中要使
  用数据结构。
▪ 常见的数据结构：

- 数组
- 队列
- 栈
- 链表
- 二叉树
- 哈希表/散列表
- ······


				▪ 方法代码片段存在哪里？方法执行的时候执行过程的内存在哪里分配？

- 方法代码片段属于.class字节码文件的一部分，字节码文件在加载的时候，将其放到了方法区当中。所以JVM中的三块主要当前内存空间中方法区内存最先有数据。存放了代码片段。

- 代码片段虽然在方法区内存当中只有一份，但是可以被重复调用。每一次调用这个方法的时候，需要给该方法分配独立的活动场所,在栈内存中分配。【栈内存中分配方法运行的所属内存空间】

- 方法在调用的时候，会给该方法分配独立的内存空间，在栈中分配，此时发生压栈动作，方法结束后，给该方法分配的内存空间全部释放，此时发生弹栈动作。

  重点：方法调用的时候，在参数传递的时候，实际上传递的是变量中保存的那个“值”传过去了。
  方法重载
  	方法重载又被称为：overload
  	什么时候考虑使用方法重载?

- 功能相似的时候

  什么条件满足之后构成了方法重载？

- 在同一个类当中

- 方法名相同
  参数列表不同：

- 数量不同

- 顺序不同

- 类型不同

  方法重载和什么有关系？
  与方法名+参数列表有关
  与返回值类型无关
  与修饰符列表无关
  方法递归
  	什么是递归？
  方法自身调用自身
  	递归非常的消耗内存，能不用就别用
  递归必须有结束条件，没有结束条件一定会发生栈内存溢出错误
  如果递归太深了，即使有结束条件，也可能发生栈内存溢出
  		

  	RecursionTest02.java
  		递归实例