---
icon: note
date: 2022-08-30
order: 6
category:
  - mybatis
---

# 6. 配置 environments

Mybatis 可以配置成适应多种环境

**但是每个 SqlSessionFactory 实例只能选择一种环境:**

Mybatis 默认的事务管理器就是 jdbc, 连接池:POOLED

```xml
<environments default="mydev">
    <environment id="mydev">
        <!--
              transactionManager:mybatis提交事务，回顾事务的方式
                 type: 事务的处理的类型
                     1）JDBC : 表示mybatis底层是调用JDBC中的Connection对象的，commit， rollback
                     2）MANAGED : 把mybatis的事务处理委托给其它的容器（一个服务器软件，一个框架（spring））
            -->
        <transactionManager type="JDBC"/>
        <!--
               dataSource:表示数据源，java体系中，规定实现了javax.sql.DataSource接口的都是数据源。
                          数据源表示Connection对象的。

               type:指定数据源的类型
                  1）POOLED: 使用连接池， mybatis会创建PooledDataSource类
                  2）UPOOLED: 不使用连接池， 在每次执行sql语句，先创建连接，执行sql，在关闭连接
                              mybatis会创建一个UnPooledDataSource，管理Connection对象的使用
                  3）JNDI：java命名和目录服务（windows注册表）
            -->
        <dataSource type="POOLED">
            <!--数据库的驱动类名-->
            <property name="driver" value="${jdbc.driver}"/>
            <!--连接数据库的url字符串-->
            <property name="url" value="${jdbc.url}"/>
            <!--访问数据库的用户名-->
            <property name="username" value="${jdbc.user}"/>
            <!--密码-->
            <property name="password" value="${jdbc.passwd}"/>
        </dataSource>
    </environment>
</environments>
```

## 1. 属性（properties）

这些属性可以在外部进行配置，并可以进行动态替换。你既可以在典型的 Java 属性文件中配置这些属性.
该属性必须在配置文件的第一行
![属性](https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/202208271710643.png)
也可以直接在 properties 元素的子元素中配置属性 **外部文件优先级更高**

```properties
<properties>
<property name="username" value="dev_user"/>
<property name="password" value="F2Fa3!33TYyg"/>
</properties>
```

## 2. 类型别名（typeAliases）

类型别名可为 Java 类型设置一个缩写名字。 它仅用于 XML 配置，意在降低冗余的全限定类名书写。例如：

```xml
<typeAliases>
    <typeAlias alias="Author" type="domain.blog.Author"/>
    <typeAlias alias="Blog" type="domain.blog.Blog"/>
    <typeAlias alias="Comment" type="domain.blog.Comment"/>
    <typeAlias alias="Post" type="domain.blog.Post"/>
    <typeAlias alias="Section" type="domain.blog.Section"/>
    <typeAlias alias="Tag" type="domain.blog.Tag"/>
</typeAliases>
```

当这样配置时，`Blog` 可以用在任何使用 `domain.blog.Blog` 的地方。

也可以指定一个包名，MyBatis 会在包名下面搜索需要的 Java Bean，比如：

```xml
<typeAliases>
    <package name="domain.blog"/>
</typeAliases>
```

每一个在包 `domain.blog` 中的 Java Bean，**在没有注解的情况下，会使用 Bean 的首字母小写的非限定类名来作为它的别名**。 比如 `domain.blog.Author` 的别名为 `author`；若有注解，则别名为其注解值。见下面的例子：

```java
@Alias("author")
public class Author {
    ...
}
```

## 3.设置（settings）

这是 MyBatis 中极为重要的调整设置，它们会改变 MyBatis 运行时的行为。

![设置](https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/202208271711429.png)

![设置2](https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/202208271711011.png)

```xml
<settings>
    <setting name="logImpl" value="LOG4J"/>
</settings>
```

## 4.其他设置

类型处理器（typeHandlers）

对象工厂（objectFactory）

插件（plugins）

1. mybatis-generator-core
2. mybatis-plus
3. 通用 mapper

## 5.映射器（mappers）

MapperRegistry: 注册绑定 mapper 文件

方式一:

```xml
<!-- 使用相对于类路径的资源引用 -->
<mappers>
    <mapper resource="org/mybatis/builder/AuthorMapper.xml"/>
    <mapper resource="org/mybatis/builder/BlogMapper.xml"/>
    <mapper resource="org/mybatis/builder/PostMapper.xml"/>
</mappers>
```

方式二:使用 class 文件进行绑定注册

```xml
<!-- 使用映射器接口实现类的完全限定类名 -->
<mappers>
    <mapper class="org.mybatis.builder.AuthorMapper"/>
    <mapper class="org.mybatis.builder.BlogMapper"/>
    <mapper class="org.mybatis.builder.PostMapper"/>
</mappers>
```

**注意点:**

- 接口和他的 mapper 配置文件必须同名
- 接口和他的 mapper 配置文件必须在同一个包下

方式三:使用扫描包进行注入绑定

```xml
<!-- 将包内的映射器接口实现全部注册为映射器 -->
<mappers>
    <package name="org.mybatis.builder"/>
</mappers>
```

**注意点:**

- 接口和他的 mapper 配置文件必须同名
- 接口和他的 mapper 配置文件必须在同一个包下

## 作用域（Scope）和生命周期

生命周期和作用域是至关重要的，因为错误的使用会导致非常严重的**并发问题**

![作用域](https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/202208271711171.png)
**SqlSessionFactoryBuilder**

一旦创建了 SqlSessionFactoryBuilder 后,就不在需要了

可定义为局部变量

**SqlSessionFactory:**

可以想象为数据库连接池

一旦创建就应该在运行期间一直存在,**没有任何理由去丢弃它后重新创建另一个实例**

因此 SqlSessionfactory 的最佳作用域是应用作用域

最简单的就死使用**单例模式**或者静态单例模式

**SqlSession:**

连接池的一个请求

用完之后需要感赶紧关闭,否则资源被占用
