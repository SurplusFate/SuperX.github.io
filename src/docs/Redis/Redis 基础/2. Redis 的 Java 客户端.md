---
icon: note
date: 2022-10-21
order: 2
category:
  - Redis
---

# Redis 的 Java 客户端

在 Redis 官网中提供了各种语言的客户端，地址：<https://redis.io/docs/clients/>

![image-20221021203407201](https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/202210212034241.png)

其中 Java 客户端也包含很多：

![image-20221021203525921](https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/202210212035967.png)

标记为 `*` 的就是推荐使用的 java 客户端，包括：

Jedis 和 Lettuce：这两个主要是提供了 Redis 命令对应的 API，方便我们操作 Redis，而 SpringDataRedis 又对这两种做了抽象和封装，因此我们后期会直接以 SpringDataRedis 来学习。

Redisson：是在 Redis 基础上实现了分布式的可伸缩的 java 数据结构，例如 Map、 Queue 等，而且支持跨进程的同步机制：Lock、Semaphore 等待，比较适合用来实现特殊的功能需求。

## Jedis 客户端

Jedis 的官网地址： <https://github.com/redis/jedis>

### Jedis 快速入门

#### 引入 Jedis 依赖

```xml
<!--jedis-->
<dependency>
    <groupId>redis.clients</groupId>
    <artifactId>jedis</artifactId>
    <version>3.7.0</version>
</dependency>
<!--junit测试-->
<dependency>
    <groupId>org.junit.jupiter</groupId>
    <artifactId>junit-jupiter</artifactId>
    <scope>test</scope>
</dependency>
```

#### 直连方式

```java
private Jedis jedis;
@BeforeEach
void setUp() {
    // 1.建立连接
    jedis = new Jedis("192.168.150.101", 6379);
    // 2.输入密码
    jedis.auth("123321");
    // 3.选择库
    jedis.select(0);
}
```

#### 测试结果

```java
@Test
void testString() {
    // 存入数据
    String result = jedis.set("name", "虎哥");
    System.out.println("result = " + result);
    // 获取数据
    String name = jedis.get("name");
    System.out.println("name = " + name);
}

@Test
void testHash() {
    // 插入hash数据
    jedis.hset("user:1", "name", "Jack");
    jedis.hset("user:1", "age", "21");

    // 获取
    Map<String, String> map = jedis.hgetAll("user:1");
    System.out.println(map);
}
```

#### 释放资源

```java
@AfterEach
void tearDown() {
    if (jedis != null) {
        jedis.close();
    }
}
```

### 连接池

Jedis 本身是线程不安全的，并且频繁的创建和销毁连接会有性能损耗，因此我们推荐大家使用 Jedis 连接池代替 Jedis 的直连方式。

```java
public class JedisConnectionFactory {
    private static JedisPool jedisPool;

    static {
        // 配置连接池
        JedisPoolConfig poolConfig = new JedisPoolConfig();
        poolConfig.setMaxTotal(8); // 最大连接数
        poolConfig.setMaxIdle(8);// 最大预留连接
        poolConfig.setMinIdle(0);// 最小预留连接
        poolConfig.setMaxWaitMillis(1000);// 最大等待时间(已过时)
        // 创建连接池对象，参数：连接池配置、服务端ip、服务端端口、超时时间、密码
        jedisPool = new JedisPool(poolConfig,
                "192.168.202.100", 6379, 1000, "123321");
    }

    public static Jedis getJedis() {
        return jedisPool.getResource();
    }
}
```

使用工具类替换直连方式:

```java
@BeforeEach
void setUp() {
    // 1.建立连接
    // jedis = new Jedis("192.168.202.100", 6379);
    jedis = JedisConnectionFactory.getJedis();
    // 2.输入密码
    // jedis.auth("123321");
    // 3.选择库
    jedis.select(0);
}
```

## SpringDataRedis 客户端

SpringData 是 Spring 中数据操作的模块，包含对各种数据库的集成，其中对 Redis 的集成模块就叫做 SpringDataRedis，官网地址：<https://spring.io/projects/spring-data-redis>

- 提供了对不同 Redis 客户端的整合（Lettuce 和 Jedis）
- 提供了 RedisTemplate 统一 API 来操作 Redis
- 支持 Redis 的发布订阅模型
- 支持 Redis 哨兵和 Redis 集群
- 支持基于 Lettuce 的响应式编程
- 支持基于 JDK、JSON、字符串、Spring 对象的数据序列化及反序列化
- 支持基于 Redis 的 JDKCollection 实现

SpringDataRedis 中提供了 RedisTemplate 工具类，其中封装了各种对 Redis 的操作。并且将不同数据类型的操作 API 封装到了不同的类型中：

![image-20221021211153177](https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/202210212111218.png)

### 快速入门

SpringBoot 已经提供了对 SpringDataRedis 的支持，使用非常简单。

#### 引入依赖

```xml
<!--redis依赖-->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-redis</artifactId>
</dependency>
```

#### 配置 Redis

可直接使用 `yml` 配置

```yaml
spring:
  redis:
    host: 192.168.202.100
    port: 6379
    password: 123321
    lettuce:
      pool:
        max-active: 8
        max-idle: 8
        min-idle: 0
        max-wait: 100ms
```

#### 注入 RedisTemplate

因为有了 SpringBoot 的自动装配，我们可以拿来就用

```java
@SpringBootTest
class RedisApplicationTests {

    // 自动装配
    @Autowired
    private RedisTemplate redisTemplate;
}
```

#### 测试

```java
@Test
void testString() {
    // 写入一条String数据
    redisTemplate.opsForValue().set("name", "虎哥");
    // 获取string数据
    Object name = redisTemplate.opsForValue().get("name");
    System.out.println("name = " + name);
}
```

#### 自定义序列化

RedisTemplate 可以接收任意 Object 作为值写入 Redis，只不过写入前会把 Object 序列化为字节形式，默认是采用 JDK 序列化，得到的结果是这样的：

![image-20221021213015365](https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/202210212130400.png)

缺点：

- 可读性差
- 内存占用较大

自定义 RedisTemplate 的序列化方式：

引入 jackjson:

```xml
<dependency>
    <groupId>com.fasterxml.jackson.core</groupId>
    <artifactId>jackson-databind</artifactId>
</dependency>
```

使用配置类配置:

```java
@Configuration
public class ConfigApplication {
    @Bean
    public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory connectionFactory) {
        // 创建RedisTemplate对象
        RedisTemplate<String, Object> template = new RedisTemplate<>();
        // 设置连接工厂
        template.setConnectionFactory(connectionFactory);
        // 创建JSON序列化工具
        GenericJackson2JsonRedisSerializer jsonRedisSerializer = new GenericJackson2JsonRedisSerializer();
        // 设置Key的序列化
        template.setKeySerializer(RedisSerializer.string());
        template.setHashKeySerializer(RedisSerializer.string());
        // 设置Value的序列化
        template.setValueSerializer(jsonRedisSerializer);
        template.setHashValueSerializer(jsonRedisSerializer);
        // 返回
        return template;
    }
}
```

这里采用了 JSON 序列化来代替默认的 JDK 序列化方式。

![image-20221025141009390](https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/202210251410646.png)

::: tip

JSON 默认的序列化方式在进行反序列化的时候需要依赖实体类的无参构造, 否则会反序列化失败

:::

#### StringRedisTemplate

为了节省内存空间，我们可以不使用 JSON 序列化器来处理 value，而是统一使用 String 序列化器，要求只能存储 String 类型的 key 和 value。当需要存储 Java 对象时，手动完成对象的序列化和反序列化。

![image-20221025141322698](https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/202210251413757.png)

这种用法比较普遍，因此 SpringDataRedis 就提供了 RedisTemplate 的子类： StringRedisTemplate，它的 key 和 value 的序列化方式默认就是 String 方式。

![image-20221025141407377](https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/202210251414446.png)

省去了我们自定义 RedisTemplate 的序列化方式的步骤，而是直接使用：

```java
@Autowired
private StringRedisTemplate stringRedisTemplate;
// json工具
private static final ObjectMapper mapper = new ObjectMapper();

@Test
void saveUser() throws JsonProcessingException {
    User user = new User("虎哥", 21);
    // 手动序列化
    String json = mapper.writeValueAsString(user);
    // 写入数据
    stringRedisTemplate.opsForValue().set("user:200", json);
    // 获取数据
    String jsonUser = stringRedisTemplate.opsForValue().get("user:200");
    // 手动反序列化
    User user1 = mapper.readValue(jsonUser, User.class);
    System.out.println("user1 = " + user1);
}
```

::: tip

序列化后的数据与序列化前的数据在 redis 中不一样，RedisTemplate 默认不序列化，无法通过 StringRedisTemplate 获取，反过来同理。

:::

##### 操作 hash 类型

```java
@Test
void testHash() {
    stringRedisTemplate.opsForHash().put("user:400", "name", "小明");
    stringRedisTemplate.opsForHash().put("user:400", "age", "21");

    Map<Object, Object> entries = stringRedisTemplate.opsForHash().entries("user:400");
    System.out.println(entries);
}
```

![image-20221025143023080](https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/202210251430173.png)

```shell
{name=小明, age=21}
```
