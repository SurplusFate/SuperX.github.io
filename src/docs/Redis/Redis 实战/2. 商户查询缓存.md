---
icon: note
date: 2022-10-26
order: 2
category:
  - Redis
---

# 商户查询缓存

缓存(Cache),就是数据交换的缓冲区,俗称的缓存就是缓冲区内的数据,一般从数据库中获取,存储于本地代码

缓存数据存储于代码中,而代码运行在内存中,内存的读写性能远高于磁盘,缓存可以大大 降低用户访问并发量带来的服务器读写压力

实际开发过程中,企业的数据量,少则几十万,多则几千万,这么大数据量,如果没有缓存来 作为"避震器",系统是几乎撑不住的,所以企业会大量运用到缓存技术;

但是缓存也会增加代码复杂度和运营的成本:

![image-20221026090003553](https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/202210260900680.png)

实际开发中,会构筑多级缓存来使系统运行速度进一步提升,例如:本地缓存与 redis 中的缓存并发使用

**浏览器缓存：** 主要是存在于浏览器端的缓存

**应用层缓存：** 可以分为 tomcat 本地缓存，比如之前提到的 map，或者是使用 redis 作为缓存

**数据库缓存：** 在数据库中有一片空间是 buffer pool，增改查数据都会先加载到 mysql 的缓存中

**CPU 缓存：** 当代计算机最大的问题是 cpu 性能提升了，但内存读写速度没有跟上，所以为了适应当下的情况，增加了 cpu 的 L1，L2，L3 级的缓存

![image-20221026090314769](https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/202210260903820.png)

## 添加商户缓存

> 1. 判断 redis 是否有商户缓存
>    1. 存在则直接返回
> 2. 从数据库中查出商户信息
>    1. 不存在报错
> 3. 将商户信息保存在 redis 中 `cache_shop: + id`
> 4. 返回商品信息

标准的操作方式就是查询数据库之前先查询缓存，如果缓存数据存在，则直接从缓存中返回，如果缓存数据不存在，再查询数据库，然后将数据存入 redis。

![image-20221026090711744](https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/202210260907832.png)

```java
@Override
public Result queryById(Long id) {
    // 1.判断 redis 是否有商户缓存
    String key = RedisConstants.CACHE_SHOP_KEY + id;
    String shopJson = redisTemplate.opsForValue().get(key);
    // 存在则直接返回
    if (StrUtil.isNotBlank(shopJson)) {
        Shop shop = JSONUtil.toBean(shopJson, Shop.class);
        return Result.ok(shop);
    }
    // 2. 不存在则查询数据库
    Shop shop = this.getById(id);
    if (shop == null) {
        return Result.fail("商品不存在");
    }
    redisTemplate.opsForValue().set(RedisConstants.CACHE_SHOP_KEY + id, JSONUtil.toJsonStr(shop));
    return Result.ok(shop);
}
```

## 缓存更新策略

缓存更新是 redis 为了节约内存而设计出来的一个东西，主要是因为内存数据宝贵，当我们向 redis 插入太多数据，此时就可能会导致缓存中的数据过多，所以 redis 会对部分数据进行更新，或者把他叫为淘汰更合适。

**内存淘汰：** redis 自动进行，当 redis 内存达到咱们设定的 max-memery 的时候，会自动触发淘汰机制，淘汰掉一些不重要的数据(可以自己设置策略方式)

**超时剔除：** 当我们给 redis 设置了过期时间 ttl 之后，redis 会将超时的数据进行删除，方便咱们继续使用缓存

**主动更新：** 我们可以手动调用方法把缓存删掉，通常用于解决缓存和数据库不一致问题

![image-20221026145619102](https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/202210261456170.png)

### 数据库缓存不一致解决方案

由于我们的**缓存的数据源来自于数据库**, 而数据库的**数据是会发生变化**的, 如果数据库中**数据发生变化,而缓存却没有同步**, 此时就会有**一致性问题存在**

解决方案:

> Cache Aside Pattern **人工编码方式**: 缓存调用者在更新完数据库后再去更新缓存，也称之为双写方案
>
> Read/Write Through Pattern: 由系统本身完成，数据库与缓存的问题交由系统本身去处理
>
> Write Behind Caching Pattern: 调用者只操作缓存，其他线程去异步处理数据库，实现最终一致

![image-20221026145934431](https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/202210261459490.png)

综合考虑使用方案一，但是方案一调用者如何处理呢？

**删除缓存还是更新缓存？**

- 更新缓存：每次更新数据库都更新缓存，无效写操作较多

- 删除缓存：更新数据库时让缓存失效，查询时再更新缓存(懒加载)

**如何保证缓存与数据库的操作的同时成功或失败？**

- 单体系统，将缓存与数据库操作放在一个事务

- 分布式系统，利用 TCC 等分布式事务方案

**先操作缓存还是先操作数据库？**

- 先删除缓存，再操作数据库

- 先操作数据库，再删除缓存

![image-20221026150318940](https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/202210261503007.png)

最佳实践:

![image-20221026151959231](https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/202210261519282.png)

### 实现商铺和缓存与数据库双写一致

> 1. 写入缓存时同时设置过期时间
>
> 2. 更新时先操作数据库，再删除缓存，使用 `@Transactional` 注解保证事务

修改 `queryById` 方法

**设置 redis 缓存时添加过期时间:**

```java
stringRedisTemplate.opsForValue().set(CACHE_SHOP_KEY + id, JSONUtil.toJsonStr(shop), CACHE_SHOP_TTL, TimeUnit.MINUTES);
```

**更新商铺的业务方法:**

```java
@Override
@Transactional
public Result updateShop(Shop shop) {
    // 更新数据库
    if (shop.getId() == null) {
        return Result.fail("商铺 id 为空");
    }
    this.updateById(shop);
    // 删除缓存
    stringRedisTemplate.delete(CACHE_SHOP_KEY);
    return Result.ok();
}
```

## 缓存穿透

缓存穿透：==缓存穿透是指客户端请求的数据在缓存中和数据库中都不存在，这样缓存永远不会生效，这些请求都会打到数据库==。

两种应对方案:

- 缓存空对象

  优点：实现简单，维护方便

  缺点：额外的内存消耗 可能造成短期的不一致

- 布隆过滤

  优点：内存占用较少，没有多余 key

  缺点：实现复杂 存在误判可能

![image-20221026154823594](https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/202210261548649.png)

**缓存空对象：** 当我们客户端访问不存在的数据时，先请求 redis，但是此时 redis 中没有数据，此时会访问到数据库，但是数据库中也没有数据，这个数据穿透了缓存，直击数据库，我们都知道数据库能够承载的并发不如 redis 这么高，如果大量的请求同时过来访问这种不存在的数据，这些请求就都会访问到数据库，简单的解决方案就是哪怕这个数据在数据库中也不存在，我们也把这个数据存入到 redis 中去，这样，下次用户过来访问这个不存在的数据，那么在 redis 中也能找到这个数据就不会进入到缓存了

**布隆过滤：** 布隆过滤器其实采用的是哈希思想来解决这个问题，通过一个庞大的二进制数组，走哈希思想去判断当前这个要查询的这个数据是否存在，如果布隆过滤器判断存在，则放行，这个请求会去访问 redis，哪怕此时 redis 中的数据过期了，但是数据库中一定存在这个数据，在数据库中查询出来这个数据后，再将其放入到 redis 中，假设布隆过滤器判断这个数据不存在，则直接返回

这种方式优点在于节约内存空间，存在误判，误判原因在于：==布隆过滤器走的是哈希思想，只要是哈希思想，就可能存在哈希冲突==

缓存空对象方式:

![image-20221026160212635](https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/202210261602699.png)

```java
log.info("商品不存在");
// 2. 缓存不存在则查询数据库
Shop shop = this.getById(id);
if (shop == null) {
    // 缓存 null 值
    stringRedisTemplate.opsForValue().set(CACHE_SHOP_KEY + id, "", CACHE_NULL_TTL, TimeUnit.MINUTES);
    return Result.fail("商品不存在");
}
```

**总结:**

> 缓存穿透产生的原因是什么？
>
> - 用户请求的数据在缓存中和数据库中都不存在，不断发起这样的请求，给数据库带来巨大压力
>
> 缓存穿透的解决方案有哪些？
>
> - 缓存 null 值
> - 布隆过滤
> - 增强 id 的复杂度，避免被猜测 id 规律
> - 做好数据的基础格式校验
> - 加强用户权限校验
> - 做好热点参数的限流

## 缓存雪崩

缓存雪崩是指在同一时段大量的缓存 key 同时失效或者 Redis 服务宕机，导致大量请求到达数据库，带来巨大压力。

![image-20221026160558929](https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/202210261605999.png)

解决方案：

- **给不同的 Key 的 TTL 添加随机值**

- 利用 **Redis 集群** 提高服务的可用性

- 给缓存业务添加**降级限流策略**

- 给业务添加**多级缓存**

## 缓存击穿

缓存击穿问题也叫**热点 Key**问题，就是一个被**高并发访问**并且**缓存重建业务较复杂的 key**突然失效了，无数的请求访问会在瞬间给数据库带来巨大的冲击。

假设线程 1 在查询缓存之后，本来应该去查询数据库，然后把这个数据重新加载到缓存的，此时只要线程 1 走完这个逻辑，其他线程就都能从缓存中加载这些数据了，但是假设在线程 1 没有走完的时候，后续的线程 2，线程 3，线程 4 同时过来访问当前这个方法， 那么这些线程都不能从缓存中查询到数据，那么他们就会同一时刻来访问查询缓存，都没查到，接着同一时间去访问数据库，同时的去执行数据库代码，对数据库访问压力过大

![image-20221026160919577](https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/202210261609663.png)

常见的解决方案有两种：

- 互斥锁
- 逻辑过期

**解决方案一、使用锁来解决：**

因为锁能实现互斥性。假设线程过来，只能一个人一个人的来访问数据库，从而避免对于数据库访问压力过大，但这也会影响查询的性能，因为此时会让查询的性能从并行变成了串行，我们可以采用 tryLock 方法 + double check 来解决这样的问题。

假设现在线程 1 过来访问，他查询缓存没有命中，但是此时他获得到了锁的资源，那么线 程 1 就会一个人去执行逻辑，假设现在线程 2 过来，线程 2 在执行过程中，并没有获得到锁，那么线程 2 就可以进行到休眠，直到线程 1 把锁释放后，线程 2 获得到锁，然后再来执行逻辑，此时就能够从缓存中拿到数据了。

![image-20221026161134509](https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/202210261611585.png)

**解决方案二、逻辑过期方案:**

方案分析：我们之所以会出现这个缓存击穿问题，主要原因是在于我们对 key 设置了过期时间，假设我们不设置过期时间，其实就不会有缓存击穿的问题，但是不设置过期时间，这样数据不就一直占用我们内存了吗，我们可以采用逻辑过期方案。

我们把过期时间设置在 redis 的 value 中，注意：这个过期时间并不会直接作用于 redis，而是我们后续通过逻辑去处理。

假设线程 1 去查询缓存，然后从 value 中判断出来当前的数据已经过期了，此时线程 1 去获得互斥锁，那么其他线程会进行阻塞，获得了锁的线程他会开启一个线程去进行以前的重构数据的逻辑，直到新开的线程完成这个逻辑后，才释放锁，而线程 1 直接进行返回，假设现在线程 3 过来访问，由于线程线程 2 持有着锁，所以线程 3 无法获得锁，线程 3 也直接返回数据，只有等到新开的线程 2 把重建数据构建完后，其他线程才能走返回正确的数据。

这种方案巧妙在于，异步的构建缓存，缺点在于在构建完缓存之前，返回的都是脏数据。

![image-20221026161401683](https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/202210261614738.png)

**互斥锁方案：** 由于保证了互斥性，所以数据一致，且实现简单，因为仅仅只需要加一把锁 而已，也没其他的事情需要操心，所以没有额外的内存消耗，缺点在于有锁就有死锁问题 的发生，且只能串行执行性能肯定受到影响

**逻辑过期方案：** 线程读取过程中不需要等待，性能好，有一个额外的线程持有锁去进行重构数据，但是在重构数据完成前，其他的线程只能返回之前的数据，且实现起来麻烦

![image-20221026161519355](https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/202210261615409.png)

### 互斥锁

> 1. 缓存不存在，获得锁 setnx，键的设计 `lock:shop: + id`，设置过期时间为 10s
>    1. 获取锁失败，休眠 50ms, 重新执行
>    2. 获取锁成功，再次查看缓存是否存在，DoubleCheck，存在则无需再构建缓存
> 2. 查数据库，将缓存写到 redis 中
> 3. 释放锁 del

![image-20221026163745714](https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/202210261637786.png)

加锁和释放锁

```java
private boolean tryLock(String key) {
    Boolean flag = stringRedisTemplate.opsForValue().setIfAbsent(key, "1", LOCK_SHOP_TTL, TimeUnit.SECONDS);
    return BooleanUtil.isTrue(flag);
}

private void unlock(String key) {
    stringRedisTemplate.delete(key);
}
```

互斥锁实现

```java
public Shop queryWithMutex(Long id) {
    // 1.判断 redis 是否有缓存
    String key = CACHE_SHOP_KEY + id;
    String shopJson = stringRedisTemplate.opsForValue().get(key);
    if (StrUtil.isNotBlank(shopJson)) {
        // 2.存在则直接返回
        return JSONUtil.toBean(shopJson, Shop.class);
    }
    // 判断是否为 空字符串: ""
    if (shopJson != null) {
        return null;
    }
    String lockKey = null;
    Shop shop = null;
    try {
        // 3.缓存不存在，获取锁
        lockKey = LOCK_SHOP_KEY + id;
        if (!tryLock(lockKey)) {
            // 4. 获取锁失败，休眠 50ms, 重新执行
            Thread.sleep(50);
            return queryWithMutex(id);
        }
        // 5.获取锁成功，再次查看缓存是否存在，DoubleCheck，存在则无需再构建缓存
        shopJson = stringRedisTemplate.opsForValue().get(key);
        if (StrUtil.isNotBlank(shopJson)) {
            // 5.1 存在则直接返回
            return JSONUtil.toBean(shopJson, Shop.class);
        }
        // 6.从数据库中查出商铺信息
        shop = this.getById(id);
        // 模拟重建时间
        Thread.sleep(200);
        // 7.不存在
        if (shop == null) {
            // 缓存空值，并设置过期时间为 2 分钟
            stringRedisTemplate.opsForValue().set(key, "", CACHE_NULL_TTL, TimeUnit.MINUTES);
            return null;
        }
        // 8.将商铺信息保存在 redis 中 `cache_shop: + id`，同时设置过期时间
        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(shop), CACHE_SHOP_TTL, TimeUnit.MINUTES);
    } catch (InterruptedException e) {
        e.printStackTrace();
    } finally {
        // 9.释放锁
        unlock(lockKey);
    }
    // 10.返回商铺信息
    return shop;
}
```

### 逻辑过期

> 1. 判断缓存是否存在
> 2. 不存在，返回空
> 3. 存在，从 redis 中取出数据
> 4. 判断是否过期
> 5. 不过期，返回数据
> 6. 过期，获得互斥锁
>    1. 获取锁失败，返回过期的数据
>    2. 获取锁成功
>    3. DoubleCheck，判断缓存是否过期
>    4. 不过期，返回数据
>    5. 过期，开启新线程，重建缓存
>    6. 释放锁
> 7. 返回过期数据

思路分析：当用户开始查询 redis 时，判断是否命中，如果没有命中则直接返回空数据， 不查询数据库，而一旦命中后，将 value 取出，判断 value 中的过期时间是否满足，如果没有过期，则直接返回 redis 中的数据，如果过期，则在开启独立线程后直接返回之前的数据，独立线程去重构数据，重构完成后释放互斥锁。

![image-20221026181022730](https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/202210261810293.png)

新建一个实体类, 避免修改原代码

```java
@Data
public class RedisData<T> {
    private LocalDateTime expireTime;
    private T data;
}
```

缓存预热

```java
/**
 * 缓存热点数据
 */
public void saveShop2Redis(Long id, Long expireSeconds) throws InterruptedException {
    // 1.查数据库，得到商铺信息
    Shop shop = this.getById(id);
    // 模拟重建时间
    Thread.sleep(200);
    // 2.封装过期时间
    RedisData<Shop> redisData = new RedisData<>();
    redisData.setExpireTime(LocalDateTime.now().plusSeconds(expireSeconds));
    redisData.setData(shop);
    // 3.将热点数据存入 redis 中
    stringRedisTemplate.opsForValue().set(CACHE_SHOP_KEY + id, JSONUtil.toJsonStr(redisData));
}
```

逻辑过期实现

```java
// 线程池
private static final ExecutorService CACHE_REBUILD_EXECUTOR = Executors.newFixedThreadPool(10);
// 逻辑过期
public Shop queryWithLogicalExpire(Long id) {
    String key = CACHE_SHOP_KEY + id;
    // 1.从redis查询商铺缓存
    String json = stringRedisTemplate.opsForValue().get(key);
    // 2.判断是否存在
    if (StrUtil.isBlank(json)) {
        // 3.存在，直接返回
        return null;
    }
    // 4.命中，需要先把json反序列化为对象
    RedisData<Shop> redisData = JSONUtil.toBean(json, new TypeReference<RedisData<Shop>>() {
    }, false);
    Shop shop = redisData.getData();
    LocalDateTime expireTime = redisData.getExpireTime();
    // 5.判断是否过期
    if (expireTime.isAfter(LocalDateTime.now())) {
        // 5.1.未过期，直接返回店铺信息
        return shop;
    }
    // 5.2.已过期，需要缓存重建
    // 6.缓存重建
    // 6.1.获取互斥锁
    String lockKey = LOCK_SHOP_KEY + id;
    boolean isLock = tryLock(lockKey);
    // 6.2.判断是否获取锁成功
    if (isLock) {
        CACHE_REBUILD_EXECUTOR.submit(() -> {
            try {
                // 重建缓存
                this.saveShop2Redis(id, 20L);
            } catch (Exception e) {
                throw new RuntimeException(e);
            } finally {
                unlock(lockKey);
            }
        });
    }
    // 6.4.返回过期的商铺信息
    return shop;
}
```

## 封装工具类

redisData

```java
@Data
public class RedisData<T> {
    private LocalDateTime expireTime;
    private T data;
}
```

CacheClient

```java
import cn.hutool.core.lang.TypeReference;
import cn.hutool.core.util.BooleanUtil;
import cn.hutool.core.util.StrUtil;
import cn.hutool.json.JSONUtil;
import com.hmdp.dto.RedisData;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.stereotype.Component;

import java.time.LocalDateTime;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import java.util.function.Function;

import static com.hmdp.utils.RedisConstants.*;

@Slf4j
@Component
public class CacheClient {
    // 线程池
    private static final ExecutorService CACHE_REBUILD_EXECUTOR = Executors.newFixedThreadPool(10);
    private final StringRedisTemplate stringRedisTemplate;

    public CacheClient(StringRedisTemplate stringRedisTemplate) {
        this.stringRedisTemplate = stringRedisTemplate;
    }

    private void set(String key, Object value, Long time, TimeUnit unit) {
        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(value), time, unit);
    }

    /**
     * 设置逻辑过期
     *
     * @param key   redisKey
     * @param value redisValue
     * @param time  逻辑过期时间值
     * @param unit  时间单位
     */
    private <T> void setWithLogicalExpire(String key, T value, Long time, TimeUnit unit) {
        // 设置逻辑过期
        RedisData<T> redisData = new RedisData<>();
        redisData.setData(value);
        redisData.setExpireTime(LocalDateTime.now().plusSeconds(unit.toSeconds(time)));
        stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(redisData));
    }

    /**
     * 普通缓存
     *
     * @param keyPrefix  keyPrefix
     * @param id         商品id
     * @param dbFallback 数据库查询方式
     * @param time       time 过期时间值
     * @param unit       unit 过期时间单位
     * @param type       type 返回值类型
     */
    public <R, ID> R queryWithPassThorough(String keyPrefix, ID id, Function<ID, R> dbFallback,
                                           Long time, TimeUnit unit, Class<R> type) {
        // 判断 redis 是否有缓存
        String key = keyPrefix + id;
        String json = stringRedisTemplate.opsForValue().get(key);
        if (StrUtil.isNotBlank(json)) {
            // 存在则直接返回
            return JSONUtil.toBean(json, type);
        }
        // 判断是否为空
        if (json != null) {
            return null;
        }
        // 从数据库中查出商铺信息
        R r = dbFallback.apply(id);
        // 不存在
        if (r == null) {
            // 缓存空值，并设置过期时间为 2 分钟
            stringRedisTemplate.opsForValue().set(key, "", CACHE_NULL_TTL, TimeUnit.MINUTES);
            return null;
        }
        // 将商铺信息保存在 redis 中 `cache_shop: + id`，同时设置过期时间
        this.set(key, r, time, unit);
        // 返回商铺信息
        return r;
    }

    /**
     * 逻辑过期
     *
     * @param keyPrefix  keyPrefix
     * @param id         商品id
     * @param dbFallback 数据库查询方式
     * @param time       time 过期时间值
     * @param unit       unit 过期时间单位
     */
    public <R, ID> R queryWithLogicalExpire(String keyPrefix, ID id, Function<ID, R> dbFallback,
                                            Long time, TimeUnit unit) {
        String key = keyPrefix + id;
        // 1.从redis查询商铺缓存
        String json = stringRedisTemplate.opsForValue().get(key);
        // 2.判断是否存在
        if (StrUtil.isBlank(json)) {
            // 3.存在，直接返回
            return null;
        }
        // 4.命中，需要先把json反序列化为对象
        RedisData<R> redisData = JSONUtil.toBean(json, new TypeReference<RedisData<R>>() {
        }, false);
        R r = redisData.getData();
        LocalDateTime expireTime = redisData.getExpireTime();
        // 5.判断是否过期
        if (expireTime.isAfter(LocalDateTime.now())) {
            // 5.1.未过期，直接返回店铺信息
            return r;
        }
        // 5.2.已过期，需要缓存重建
        // 6.缓存重建
        // 6.1.获取互斥锁
        String lockKey = LOCK_SHOP_KEY + id;
        boolean isLock = tryLock(lockKey);
        // 6.2.判断是否获取锁成功
        if (isLock) {
            CACHE_REBUILD_EXECUTOR.submit(() -> {
                try {
                    // 查询数据库
                    R r1 = dbFallback.apply(id);
                    // 重建缓存
                    this.setWithLogicalExpire(key, r1, time, unit);
                } catch (Exception e) {
                    throw new RuntimeException(e);
                } finally {
                    unlock(lockKey);
                }
            });
        }
        // 6.4.返回过期的商铺信息
        return r;
    }

    /**
     * 互斥锁
     *
     * @param keyPrefix  keyPrefix
     * @param id         商品id
     * @param dbFallback 数据库查询方式
     * @param time       time 过期时间值
     * @param unit       unit 过期时间单位
     */
    public <R, ID> R queryWithMutex(String keyPrefix, ID id, Function<ID, R> dbFallback,
                                    Long time, TimeUnit unit, Class<R> type) {
        // 1.判断 redis 是否有缓存
        String key = keyPrefix + id;
        String json = stringRedisTemplate.opsForValue().get(key);
        if (StrUtil.isNotBlank(json)) {
            // 2.存在则直接返回
            return JSONUtil.toBean(json, type);
        }
        // 判断是否为空
        if (json != null) {
            return null;
        }
        String lockKey = null;
        R r = null;
        try {
            // 3.缓存不存在，获取锁
            lockKey = LOCK_SHOP_KEY + id;
            if (!tryLock(lockKey)) {
                // 4. 获取锁失败，休眠 50ms, 重新执行
                Thread.sleep(50);
                return queryWithMutex(keyPrefix, id, dbFallback, time, unit, type);
            }
            // 5.获取锁成功，再次查看缓存是否存在，DoubleCheck，存在则无需再构建缓存
            json = stringRedisTemplate.opsForValue().get(key);
            if (StrUtil.isNotBlank(json)) {
                // 5.1 存在则直接返回
                return JSONUtil.toBean(json, type);
            }
            // 6.从数据库中查出商铺信息
            r = dbFallback.apply(id);
            // 7.不存在
            if (r == null) {
                // 缓存空值，并设置过期时间为 2 分钟
                stringRedisTemplate.opsForValue().set(key, "", CACHE_NULL_TTL, TimeUnit.MINUTES);
                return null;
            }
            // 8.将商铺信息保存在 redis 中 `cache_shop: + id`，同时设置过期时间
            stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(r), time, unit);
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            // 9.释放锁
            unlock(lockKey);
        }
        // 10.返回商铺信息
        return r;
    }

    private boolean tryLock(String key) {
        Boolean flag = stringRedisTemplate.opsForValue().setIfAbsent(key, "1", LOCK_SHOP_TTL, TimeUnit.SECONDS);
        return BooleanUtil.isTrue(flag);
    }

    private void unlock(String key) {
        stringRedisTemplate.delete(key);
    }
}
```
