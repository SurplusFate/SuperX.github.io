# 优惠卷秒杀

## 全局唯一 ID

当用户抢购时，就会生成订单并保存到 tb_voucher_order 这张表中，而订单表如果使用数据库自增 ID 就存在一些问题：

- id 的规律性太明显

- 受单表数据量的限制

如果我们的 id 具有太明显的规则，用户或者说商业对手很容易猜测出来我们的一些敏感信息，比如商城在一天时间内，卖出了多少单，这明显不合适。

随着我们商城规模越来越大，mysql 的单表的容量不宜超过 500W，数据量过大之后，我们要进行拆库拆表，但拆分表了之后，从逻辑上讲他们是同一张表，所以他们的 id 是不能一样的， 于是乎我们需要保证 id 的唯一性。

**全局 ID 生成器**，是一种在分布式系统下用来生成全局唯一 ID 的工具，一般要满足下列特性：

![image-20221027175508412](https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/202210271755539.png)

为了增加 ID 的安全性，我们可以不直接使用 Redis 自增的数值，而是拼接一些其它信息：

ID 的组成部分：符号位：1bit，永远为 0

时间戳：31bit，以秒为单位，可以使用 69 年

序列号：32bit，秒内的计数器，支持每秒产生 2^32 个不同 ID

### Redis 实现全局唯一 Id

```java
@Component
public class RedisIdWorker {
    /**
     * 开始时间戳
     */
    private static final long BEGIN_TIMESTAMP = 1640995200L;
    /**
     * 序列号的位数
     */
    private static final int COUNT_BITS = 32;

    private final StringRedisTemplate stringRedisTemplate;

    public RedisIdWorker(StringRedisTemplate stringRedisTemplate) {
        this.stringRedisTemplate = stringRedisTemplate;
    }

    public long nextId(String keyPrefix) {
        // 1.生成时间戳
        LocalDateTime now = LocalDateTime.now();
        long nowSecond = now.toEpochSecond(ZoneOffset.UTC);
        long timestamp = nowSecond - BEGIN_TIMESTAMP;

        // 2.生成序列号
        // 2.1.获取当前日期，精确到天
        String date = now.format(DateTimeFormatter.ofPattern("yyyy:MM:dd"));
        // 2.2.自增长
        long count = stringRedisTemplate.opsForValue().increment("icr:" + keyPrefix + ":" + date);

        // 3.拼接并返回
        return timestamp << COUNT_BITS | count;
    }
}
```

`long count = stringRedisTemplate.opsForValue().increment("icr:" + keyPrefix + ":" + date);`

> 优点：
>
> 1. 一天一个 key， 防止 key 过大，超过限制
> 2. 可以进行统计

#### 测试类

知识小贴士：关于 `countdownlatch`

`countdownlatch` 名为信号枪：主要的作用是同步协调在多线程的等待于唤醒问题

我们如果没有 `CountDownLatch` ，那么由于程序是异步的，当异步程序没有执行完时，主线程就已经执行完了，然后我们期望的是分线程全部走完之后，主线程再走，所以我们此时需要使用到 `CountDownLatch`

`CountDownLatch` 中有两个最重要的方法

1. `countDown`

2. `await`

`await` 方法 是阻塞方法，我们担心分线程没有执行完时，`main` 线程就先执行，所以使用 `await` 可以让 `main` 线程阻塞，那么什么时候 `main` 线程不再阻塞呢？

当 `CountDownLatch` 内部维护的变量变为 0 时，就不再阻塞，直接放行，那么什么时候 `CountDownLatch` 维护的变量变为 0 呢，我们只需要调用一次 `countDown` ，内部变量就减少 1，我们让分线程和变量绑定， 执行完一个分线程就减少一个变量，当分线程全部走完，`CountDownLatch` 维护的变量就是 0，此时 await 就不再阻塞，统计出来的时间也就是所有分线程执行完后的时间。

```java
@Test
void TestRedisIdWorker() throws InterruptedException {
    CountDownLatch countDownLatch = new CountDownLatch(300);
    Runnable task = () -> {
        for (int i = 0; i < 100; i++) {
            long id = redisIdWorker.nextId("order");
            System.out.println("id:" + id);
        }
        countDownLatch.countDown();
    };
    long begin = System.currentTimeMillis();
    for (int i = 0; i < 300; i++) {
        es.submit(task);
    }
    countDownLatch.await();
    long end = System.currentTimeMillis();
    System.out.println(end - begin);
}
```

## 添加优惠卷

每个店铺都可以发布优惠券，分为平价券和特价券。平价券可以任意购买，而特价券需要 秒杀抢购：

![image-20221027200753321](https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/202210272007354.png)

`tb_voucher：`优惠券的基本信息，优惠金额、使用规则等
`tb_seckill_voucher：`优惠券的库存、开始抢购时间，结束抢购时间。特价优惠券才需要填写这些信息

平价卷由于优惠力度并不是很大，所以是可以任意领取

而代金券由于优惠力度大，所以像第二种卷，就得限制数量，从表结构上也能看出，特价卷除了具有优惠卷的基本信息以外，还具有库存，抢购时间，结束时间等等字段

添加优惠券:

**VoucherController:**

```java
/**
 * 新增普通券
 * @param voucher 优惠券信息
 * @return 优惠券id
 */
@PostMapping
public Result addVoucher(@RequestBody Voucher voucher) {
    voucherService.save(voucher);
    return Result.ok(voucher.getId());
}
/**
 * 新增秒杀券
 * @param voucher 优惠券信息，包含秒杀信息
 * @return 优惠券id
 */
@PostMapping("seckill")
public Result addSeckillVoucher(@RequestBody Voucher voucher) {
    voucherService.addSeckillVoucher(voucher);
    return Result.ok(voucher.getId());
}
```

**VoucherService:**

```java
@Override
@Transactional
public void addSeckillVoucher(Voucher voucher) {
    // 保存优惠券
    save(voucher);
    // 保存秒杀信息
    SeckillVoucher seckillVoucher = new SeckillVoucher();
    seckillVoucher.setVoucherId(voucher.getId());
    seckillVoucher.setStock(voucher.getStock());
    seckillVoucher.setBeginTime(voucher.getBeginTime());
    seckillVoucher.setEndTime(voucher.getEndTime());
    seckillVoucherService.save(seckillVoucher);
    // 保存秒杀库存到Redis中
    stringRedisTemplate.opsForValue().set(SECKILL_STOCK_KEY + voucher.getId(), voucher.getStock().toString());
}
```

**接口数据:**

```json
{
  "shopId": 1,
  "title": "100元代金券",
  "subTitle": "周一至周五均可使用",
  "rules": "全场通用\n无需预约\n可无限叠加\n不兑现、不找零\n仅限堂食",
  "payValue": 8000,
  "actualValue": 10000,
  "type": 1,
  "stock": 100,
  "beginTime": "2022-10-29T20:25:21",
  "endTime": "2023-01-29T09:55:12"
}
```

**需要设置请求头:**

![image-20221029205101996](https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/202210292051190.png)

::: tip

其实也可以直接修改数据库\~\~\~

![image-20221029205409958](https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/202210292054004.png)

![image-20221029205434733](https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/202210292054791.png)

:::

## 实现秒杀

> 1. 根据 id 查询优惠券信息
> 2. 判断秒杀是否开始
> 3. 判断秒杀是否结束
> 4. 判断库存是否充足
> 5. 扣减库存
> 6. 创建订单
>    1. 用户 id
>    2. 订单 id
>    3. 优惠券 id
> 7. 返回订单号

![image-20221027210051434](https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/202210272100494.png)

下单时需要判断两点：

- 秒杀是否开始或结束，如果尚未开始或已经结束则无法下单
- 库存是否充足，不足则无法下单

下单核心逻辑分析：

当用户开始进行下单，我们应当去查询优惠卷信息，查询到优惠卷信息，判断是否满足秒杀条件

比如时间是否充足，如果时间充足，则进一步判断库存是否足够，如果两者都满足，则扣减库存，创建订单，然后返回订单 id，如果有一个条件不满足则直接结束。

![image-20221027210213107](https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/202210272102166.png)

```java
@Override
public Result seckillVoucher(Long voucherId) {
    // 1.查询优惠券
    SeckillVoucher voucher = seckillVoucherService.getById(voucherId);
    // 2.判断秒杀是否开始
    if (voucher.getBeginTime().isAfter(LocalDateTime.now())) {
        return Result.fail("秒杀尚未开始！");
    }
    // 3.判断秒杀是否已经结束
    if (voucher.getEndTime().isBefore(LocalDateTime.now())) {
        return Result.fail("秒杀已经结束！");
    }
    // 4.判断库存是否充足
    if (voucher.getStock() < 1) {
        // 库存不足
        return Result.fail("库存不足！");
    }
    //5，扣减库存
    boolean success = seckillVoucherService.update()
            .setSql("stock= stock -1")
            .eq("voucher_id", voucherId).update();
    if (!success) {
        //扣减库存
        return Result.fail("库存不足！");
    }
    //6.创建订单
    VoucherOrder voucherOrder = new VoucherOrder();
    // 6.1.订单id
    long orderId = redisIdWorker.nextId("order");
    voucherOrder.setId(orderId);
    // 6.2.用户id
    Long userId = UserHolder.getUser().getId();
    voucherOrder.setUserId(userId);
    // 6.3.代金券id
    voucherOrder.setVoucherId(voucherId);
    save(voucherOrder);

    return Result.ok(orderId);

}
```

## 库存超卖问题

```java
if (voucher.getStock() < 1) {
    // 库存不足
    return Result.fail("库存不足！");
}
//5，扣减库存
boolean success = seckillVoucherService.update()
        .setSql("stock= stock -1")
        .eq("voucher_id", voucherId).update();
if (!success) {
    //扣减库存
    return Result.fail("库存不足！");
}
```

假设线程 1 过来查询库存，判断出来库存大于 1，正准备去扣减库存，但是还没有来得及去扣减，此时线程 2 过来，线程 2 也去查询库存，发现这个数量一定也大于 1，那么这两个线程都会去扣减库存，最终多个线程相当于一起去扣减库存，此时就会出现库存的超卖问题。

![image-20221027210504258](https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/202210272105568.png)

**悲观锁：**

悲观锁可以实现对于数据的串行化执行，比如 syn，和 lock 都是悲观锁的代表，同时，悲观锁中又可以再细分为公平锁，非公平锁，可重入锁，等等

**乐观锁：**

乐观锁：会有一个版本号，每次操作数据会对版本号+1，再提交回数据时，会去校验是否比之前的版本大 1 ，如果大 1 ，则进行操作成功，这套机制的核心逻辑在于，如果在操作过程中，版本号只比原来大 1，那么就意味着操作过程中没有人对他进行过修改，他的操作就是安全的，如果不大 1，则数据被修改过，当然乐观锁还有一些变种的处理方式比如 cas

乐观锁的典型代表：就是 cas，利用 cas 进行无锁化机制加锁，var5 是操作前读取的内存值，while 中的 var1+var2 是预估值，如果预估值 == 内存值，则代表中间没有被人修改过，此时就将新值去替换内存值

![image-20221027210615219](https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/202210272106271.png)

```java
int var5;
do {
    var5 = this.getIntVolatile(var1, var2);
} while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));

return var5;
```

其中 do while 是为了在操作失败时，再次进行自旋操作，即把之前的逻辑再操作一次。

::: info

针对 cas 中的自旋压力过大，我们可以使用 Longaddr 这个类去解决

Java8 提供的一个对 AtomicLong 改进后的一个类，LongAdder

大量线程并发更新一个原子性的时候，天然的问题就是自旋，会导致并发性问题，当然这也比我们直接使用 syn 来的好

所以利用这么一个类，LongAdder 来进行优化

如果获取某个值，则会对 cell 和 base 的值进行递增，最后返回一个完整的值

![image-20221027212218546](https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/202210272122596.png)

:::

![image-20221027211013832](https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/202210272111014.png)

操作逻辑是在操作时，对版本号进行+1 操作，然后要求 version 如果是 1 的情况下，才能操作，那么第一个线程在操作后，数据库中的 version 变成了 2，但是他自己满足 version=1 ，所以没有问题，此时线程 2 执行，线程 2 最后也需要加上条件 version =1 ，但是现在由于线程 1 已经操作过了，所以线程 2，操作时就不满足 version=1 的条件了，所以线程 2 无法执行成功

对逻辑简化，不判断版本号，直接判断 stock:

![image-20221029211222699](https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/202210292112771.png)

**方案一：**

VoucherOrderServiceImpl 在扣减库存时，改为：

```java
boolean success = seckillVoucherService.update()
            .setSql("stock= stock -1") //set stock = stock -1
            .eq("voucher_id", voucherId).eq("stock",voucher.getStock()).update(); //where id = ？ and stock = ?
```

只要我扣减库存时的库存和之前我查询到的库存是一样的，就意味着没有人在中间修改过库存，那么此时就是安全的，但是以上这种方式会有很多失败的情况；

失败的原因在于：在使用乐观锁过程中假设 100 个线程同时都拿到了 100 的库存，然后大家一起去进行扣减，但是 100 个人中只有 1 个人能扣减成功，其他的人在处理时，他们在扣减时，库存已经被修改过了，所以此时其他线程都会失败

**方案二：**

```java
boolean success = seckillVoucherService.update()
            .setSql("stock= stock -1")
            .eq("voucher_id", voucherId).update().gt("stock",0); //where id = ? and stock > 0
```

## 一人一单

**问题：**

优惠卷是为了引流，但是目前的情况是，一个人可以无限制的抢这个优惠卷，所以我们应当增加一层逻辑，让一个用户只能下一个单，而不是让一个用户下多个单

具体操作逻辑如下：比如时间是否充足，如果时间充足，则进一步判断库存是否足够，然后再根据优惠卷 id 和用户 id 查询是否已经下过这个订单，如果下过这个订单，则不再下单，否则进行下单

![image-20221027212237154](https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/202210272122204.png)

**VoucherOrderServiceImpl 初步代码, 增加一人一单逻辑:**

```java
@Override
public Result seckillVoucher(Long voucherId) {
    // 1.查询优惠券
    SeckillVoucher voucher = seckillVoucherService.getById(voucherId);
    // 2.判断秒杀是否开始
    if (voucher.getBeginTime().isAfter(LocalDateTime.now())) {
        // 尚未开始
        return Result.fail("秒杀尚未开始！");
    }
    // 3.判断秒杀是否已经结束
    if (voucher.getEndTime().isBefore(LocalDateTime.now())) {
        // 尚未开始
        return Result.fail("秒杀已经结束！");
    }
    // 4.判断库存是否充足
    if (voucher.getStock() < 1) {
        // 库存不足
        return Result.fail("库存不足！");
    }
    // 5.一人一单逻辑
    // 5.1.用户id
    Long userId = UserHolder.getUser().getId();
    int count = query().eq("user_id", userId).eq("voucher_id", voucherId).count();
    // 5.2.判断是否存在
    if (count > 0) {
        // 用户已经购买过了
        return Result.fail("用户已经购买过一次！");
    }

    //6，扣减库存
    boolean success = seckillVoucherService.update()
            .setSql("stock= stock -1")
            .eq("voucher_id", voucherId).update();
    if (!success) {
        //扣减库存
        return Result.fail("库存不足！");
    }
    //7.创建订单
    VoucherOrder voucherOrder = new VoucherOrder();
    // 7.1.订单id
    long orderId = redisIdWorker.nextId("order");
    voucherOrder.setId(orderId);

    voucherOrder.setUserId(userId);
    // 7.3.代金券id
    voucherOrder.setVoucherId(voucherId);
    save(voucherOrder);

    return Result.ok(orderId);

}
```

**存在问题：**现在的问题还是和之前一样，并发过来，查询数据库，都不存在订单，所以我们还是需要加锁，但是乐观锁比较适合更新数据，而现在是插入数据，所以我们需要使用悲观锁操作

::: tip

首先我们的初始方案是封装了一个 createVoucherOrder 方法，同时为了确保他线程安全，在方法上添加了一把 synchronized 锁

:::

```java
@Transactional
public synchronized Result createVoucherOrder(Long voucherId) {

    Long userId = UserHolder.getUser().getId();
         // 5.1.查询订单
        int count = query().eq("user_id", userId).eq("voucher_id", voucherId).count();
        // 5.2.判断是否存在
        if (count > 0) {
            // 用户已经购买过了
            return Result.fail("用户已经购买过一次！");
        }

        // 6.扣减库存
        boolean success = seckillVoucherService.update()
                .setSql("stock = stock - 1") // set stock = stock - 1
                .eq("voucher_id", voucherId).gt("stock", 0) // where id = ? and stock > 0
                .update();
        if (!success) {
            // 扣减失败
            return Result.fail("库存不足！");
        }

        // 7.创建订单
        VoucherOrder voucherOrder = new VoucherOrder();
        // 7.1.订单id
        long orderId = redisIdWorker.nextId("order");
        voucherOrder.setId(orderId);
        // 7.2.用户id
        voucherOrder.setUserId(userId);
        // 7.3.代金券id
        voucherOrder.setVoucherId(voucherId);
        save(voucherOrder);

        // 7.返回订单id
        return Result.ok(orderId);
}
```

但是这样添加锁，锁的粒度太粗了，在使用锁过程中，控制**锁粒度**是一个非常重要的事情，因为如果锁的粒度太大，会导致每个线程进来都会锁住，所以我们需要去控制锁的粒度，以下这段代码需要修改为：

```java
@Transactional
public  Result createVoucherOrder(Long voucherId) {
    Long userId = UserHolder.getUser().getId();
    synchronized(userId.toString().intern()){
         // 5.1.查询订单
        int count = query().eq("user_id", userId).eq("voucher_id", voucherId).count();
        // 5.2.判断是否存在
        if (count > 0) {
            // 用户已经购买过了
            return Result.fail("用户已经购买过一次！");
        }

        // 6.扣减库存
        boolean success = seckillVoucherService.update()
                .setSql("stock = stock - 1") // set stock = stock - 1
                .eq("voucher_id", voucherId).gt("stock", 0) // where id = ? and stock > 0
                .update();
        if (!success) {
            // 扣减失败
            return Result.fail("库存不足！");
        }

        // 7.创建订单
        VoucherOrder voucherOrder = new VoucherOrder();
        // 7.1.订单id
        long orderId = redisIdWorker.nextId("order");
        voucherOrder.setId(orderId);
        // 7.2.用户id
        voucherOrder.setUserId(userId);
        // 7.3.代金券id
        voucherOrder.setVoucherId(voucherId);
        save(voucherOrder);

        // 7.返回订单id
        return Result.ok(orderId);
    }
}
```

intern() 这个方法是从常量池中拿到数据，如果我们直接使用 userId.toString() 他拿到的对象实际上是不同的对象，是 new 出来的对象，我们使用锁必须保证锁必须是同一把，所以我们需要使用 intern()方法

但是以上代码还是存在问题，问题的原因在于当前方法被 spring 的事务控制，如果你在方法内部加锁，可能会导致当前方法事务还没有提交，但是锁已经释放也会导致问题，所以我们选择将当前方法整体包裹起来，确保事务不会出现问题，如下：

在 seckillVoucher 方法中，添加以下逻辑，这样就能保证事务的特性，同时也控制了锁的粒度

```java
Long userId = UserHolder.getUser().getId();
synchronized (userId.toString().intern()) {
    return this.createVoucherOrder(voucherId);
}
```

但是以上做法依然有问题，因为你调用的方法，其实是 this.的方式调用的，事务想要生效，还得利用代理来生效，所以这个地方，我们需要获得原始的事务对象，来操作事务

```java
Long userId = UserHolder.getUser().getId();
synchronized (userId.toString().intern()) {
     // 非事务的方法调用自身类的事务方法，事务失效
     // 获得代理对象
    IVoucherOrderService voucherOrderService =
(IVoucherOrderService) AopContext.currentProxy();
    return voucherOrderService.createVoucherOrder(voucherId);
}
```

引入 aspectj

```xml
<dependency>
    <groupId>org.aspectj</groupId>
    <artifactId>aspectjweaver</artifactId>
</dependency>
```

暴露代理对象

```java
// 暴露代理对象
@EnableAspectJAutoProxy(exposeProxy = true)
@MapperScan("com.hmdp.mapper")
@SpringBootApplication
public class HmDianPingApplication {
    public static void main(String[] args) {
        SpringApplication.run(HmDianPingApplication.class, args);
    }
}
```

> 补充：Spring 事务失效常见场景: <https://blog.csdn.net/qq_16268979/article/details/123707823>

## 集群环境下的并发问题

通过加锁可以解决在单机情况下的一人一单安全问题，但是在集群模式下就不行了。

当我们部署了多个 tomcat，每个 tomcat 都有一个属于自己的 jvm，那么假设在服务器 A 的 tomcat 内部，有两个线程，这两个线程由于使用的是同一份代码，那么他们的锁对象是同一个，是可以实现互斥的，但是如果现在是服务器 B 的 tomcat 内部，又有两个线 程，但是他们的锁对象写的虽然和服务器 A 一样，但是锁对象却不是同一个，所以线程 3 和线程 4 可以实现互斥，但是却无法和线程 1 和线程 2 实现互斥，这就是集群环境下，syn 锁失效的原因，在这种情况下，我们就需要使用分布式锁来解决这个问题。

![image-20221028103934469](https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/202210281039602.png)
