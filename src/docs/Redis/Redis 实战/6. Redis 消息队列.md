# Redis 消息队列

## 认识消息队列

什么是消息队列：字面意思就是存放消息的队列。最简单的消息队列模型包括 3 个角色：

- 消息队列：存储和管理消息，也被称为**消息代理**（Message Broker）
- 生产者：发送消息到消息队列
- 消费者：从消息队列获取消息并处理消息

![image-20221101102221209](https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/202211011022318.png)

使用队列的好处在于 **解耦：**所谓解耦，举一个生活中的例子就是：快递员(生产者)把快递放到快递柜里边(Message Queue)去，我们(消费者)从快递柜里边去拿东西，这就是一个异步，如果耦合，那么这个快递员相当于直接把快递交给你，这事固然好，但是万一你不在家，那么快递员就会一直等你，这就浪费了快递员的时间，所以这种思想在我们日常开发中，是非常有必要的。

这种场景在我们秒杀中就变成了：我们下单之后，利用 redis 去进行校验下单条件，再通过队列把消息发送出去，然后再启动一个线程去消费这个消息，完成解耦，同时也加快我们的响应速度。

这里我们可以使用一些现成的 mq，比如 kafka，rabbitmq 等等，但是呢，如果没有安装 mq，我们也可以直接使用 redis 提供的 mq 方案，降低我们的部署和学习成本。

## 基于 List 实现消息队列

**基于 List 结构模拟消息队列:**

消息队列（Message Queue），字面意思就是存放消息的队列。而 Redis 的 list 数据结构是一个双向链表，很容易模拟出队列效果。

队列是入口和出口不在一边，因此我们可以利用：LPUSH 结合 RPOP、或者 RPUSH 结合 LPOP 来实现。
不过要注意的是，当队列中没有消息时 RPOP 或 LPOP 操作会返回 null，并不像 JVM 的阻塞队列那样会阻塞并等待消息。因此这里应该使用 BRPOP 或者 BLPOP 来实现阻塞效果。

![image-20221101102417730](https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/202211011024780.png)

基于 List 的消息队列有哪些优缺点？
优点：

- 利用 Redis 存储，**不受限于 JVM 内存上限**
- 基于 Redis 的**持久化机制**，**数据安全性**有保证
- 可以满足消息有序性

缺点：

- 无法避免**消息丢失**
- 只支持**单消费者**

## 基于 PubSub 的消息队列

PubSub（发布订阅）是 Redis2.0 版本引入的消息传递模型。顾名思义，消费者可以订阅一个或多个 channel，生产者向对应 channel 发送消息后，所有订阅者都能收到相关消息。

SUBSCRIBE channel [channel] ：订阅一个或多个频道
PUBLISH channel msg ：向一个频道发送消息
PSUBSCRIBE pattern[pattern] ：订阅与 pattern 格式匹配的所有频道

![image-20221101102642213](https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/202211011026264.png)

基于 PubSub 的消息队列有哪些优缺点？
优点：

- 采用发布订阅模型，支持多生产、多消费

缺点：

- 不支持**数据持久化**
- 无法避免**消息丢失**
- **消息堆积有上限**，超出时数据丢失

## 基于 Stream 的消息队列

Stream 是 Redis 5.0 引入的一种新数据类型，可以实现一个功能非常完善的消息队列。

发送消息的命令：

![image-20221101102823691](https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/202211011028741.png)

例如：

![image-20221101102841185](https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/202211011028223.png)

读取消息的方式之一：XREAD

![image-20221101102910789](https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/202211011029844.png)

例如，使用 XREAD 读取第一个消息：

![image-20221101102925687](https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/202211011029730.png)

XREAD 阻塞方式，读取最新的消息：

![image-20221101102943447](https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/202211011029479.png)

在业务开发中，我们可以循环的调用 XREAD 阻塞方式来查询最新消息，从而实现持续监听队列的效果，伪代码如下

![image-20221101103006889](https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/202211011030935.png)

注意：当我们指定起始 ID 为$时，代表读取最新的消息，如果我们处理一条消息的过程中，又有超过 1 条以上的消息到达队列，则下次获取时也只能获取到最新的一条，会出现**漏读**消息的问题

STREAM 类型消息队列的 XREAD 命令特点：

- 消息可回溯
- 一个消息可以被多个消费者读取
- 可以阻塞读取
- 有消息**漏读**的风险

### 消费者组

消费者组（Consumer Group）：将多个消费者划分到一个组中，监听同一个队列。具备下列特点：

![image-20221101103141833](https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/202211011031892.png)

创建消费者组：

![image-20221101103211032](https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/202211011032058.png)

key：队列名称
groupName：消费者组名称
ID：起始 ID 标示，$代表队列中最后一个消息，0 则代表队列中第一个消息
MKSTREAM：队列不存在时自动创建队列
其它常见命令：

**删除指定的消费者组:**

```java
XGROUP DESTORY key groupName
```

**给指定的消费者组添加消费者:**

```java
XGROUP CREATECONSUMER key groupname consumername
```

**删除消费者组中的指定消费者:**

```java
XGROUP DELCONSUMER key groupname consumername
```

从消费者组读取消息：

```java
XREADGROUP GROUP group consumer [COUNT count] [BLOCK milliseconds] [NOACK] STREAMS key [key ...] ID [ID ...]
```

- group：消费组名称
- consumer：消费者名称，如果消费者不存在，会自动创建一个消费者
- count：本次查询的最大数量
- BLOCK milliseconds：当没有消息时最长等待时间
- NOACK：无需手动 ACK，获取到消息后自动确认
- STREAMS key：指定队列名称
- ID：获取消息的起始 ID：
  - ">"：从下一个未消费的消息开始
  - 其它：根据指定 id 从 pending-list 中获取已消费但未确认的消息，例如 0，是从 pending-list 中的第一个消息开始

消费者监听消息的基本思路：

![image-20221101103301529](https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/202211011033590.png)

STREAM 类型消息队列的 XREADGROUP 命令特点：

- 消息可回溯
- 可以多消费者争抢消息，加快消费速度
- 可以阻塞读取
- 没有消息漏读的风险
- 有消息确认机制，保证消息至少被消费一次

最后我们来个小对比

![image-20221101103331047](https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/202211011033109.png)

### 实现异步秒杀下单

> - 创建一个 Stream 类型的消息队列，名为 stream.orders
>
> ```shell
> XGROUP CREATE stream.orders g1 0 MKSTREAM
> ```
>
> - 修改之前的秒杀下单 Lua 脚本，在认定有抢购资格后，直接向 stream.orders 中添加消息，内容包含 voucherId、userId、orderId
>   - 发送消息到队列中，XADD stream.orders \* k1 v1 k2 v2
> - 项目启动时，开启一个线程任务，尝试获取 stream.orders 中的消息，完成下单
>   - 从队列中读取消息 `XREADGROUP GROUP g1 c1 count 1 BLOCK 2000 STREAM S1 >`
>   - 若消息为空，说明还没有消息，继续下次循坏
>   - 创建订单
>   - 手动 ACK XACK
>   - 出现异常，编写方法 handlePendingList
>     - 从 PendingList 中读取消息 XREADGROUP GROUP g1 c1 count 1 BLOCK 2000 STREAM S1 0
>     - 若消息为空，说明没有异常消息，结束循坏
>     - 创建订单
>     - 手动 ACK XACK
>     - 出现异常，睡眠 20 ms，继续下一次循坏

创建一个 Stream 类型的消息队列，名为 stream.orders

```shell
XGROUP CREATE stream.orders g1 0 MKSTREAM
```

修改之前的秒杀下单 Lua 脚本，在认定有抢购资格后，直接向 stream.orders 中添加消息，内容包含 voucherId、userId、orderId

![image-20221101103540093](https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/202211011036476.png)

![image-20221101103629577](https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/202211011036627.png)

项目启动时，开启一个线程任务，尝试获取 stream.orders 中的消息，完成下单

VoucherOrderServiceImpl

```java
private class VoucherOrderHandler implements Runnable {

    @Override
    public void run() {
        while (true) {
            try {
                // 1.获取消息队列中的订单信息 XREADGROUP GROUP g1 c1 COUNT 1 BLOCK 2000 STREAMS s1 >
                List<MapRecord<String, Object, Object>> list = stringRedisTemplate.opsForStream().read(
                    Consumer.from("g1", "c1"),
                    StreamReadOptions.empty().count(1).block(Duration.ofSeconds(2)),
                    StreamOffset.create("stream.orders", ReadOffset.lastConsumed())
                );
                // 2.判断订单信息是否为空
                if (list == null || list.isEmpty()) {
                    // 如果为null，说明没有消息，继续下一次循环
                    continue;
                }
                // 解析数据
                MapRecord<String, Object, Object> record = list.get(0);
                Map<Object, Object> value = record.getValue();
                VoucherOrder voucherOrder = BeanUtil.fillBeanWithMap(value, new VoucherOrder(), true);
                // 3.创建订单
                createVoucherOrder(voucherOrder);
                // 4.确认消息 XACK
                stringRedisTemplate.opsForStream().acknowledge("s1", "g1", record.getId());
            } catch (Exception e) {
                log.error("处理订单异常", e);
                //处理异常消息
                handlePendingList();
            }
        }
    }

    private void handlePendingList() {
        while (true) {
            try {
                // 1.获取pending-list中的订单信息 XREADGROUP GROUP g1 c1 COUNT 1 BLOCK 2000 STREAMS s1 0
                List<MapRecord<String, Object, Object>> list = stringRedisTemplate.opsForStream().read(
                    Consumer.from("g1", "c1"),
                    StreamReadOptions.empty().count(1),
                    StreamOffset.create("stream.orders", ReadOffset.from("0"))
                );
                // 2.判断订单信息是否为空
                if (list == null || list.isEmpty()) {
                    // 如果为null，说明没有异常消息，结束循环
                    break;
                }
                // 解析数据
                MapRecord<String, Object, Object> record = list.get(0);
                Map<Object, Object> value = record.getValue();
                VoucherOrder voucherOrder = BeanUtil.fillBeanWithMap(value, new VoucherOrder(), true);
                // 3.创建订单
                createVoucherOrder(voucherOrder);
                // 4.确认消息 XACK
                stringRedisTemplate.opsForStream().acknowledge("s1", "g1", record.getId());
            } catch (Exception e) {
                log.error("处理pendding订单异常", e);
                try{
                    Thread.sleep(20);
                }catch(Exception e){
                    e.printStackTrace();
                }
            }
        }
    }
}
```
