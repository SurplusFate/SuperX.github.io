---
icon: note
date: 2022-09-06
order: 11
category:
  - Spring
---

# 11. 事务

## 1. 事务回顾

1. 什么是事务

   1. 讲 mysql 的时候,提出了事务 事务是指一组 sql 语句的集合
   2. 集合中有多条 sql 语句可能是 insert , update ,select ,delete
   3. **我们希望这些多个 sql 语句都能成功, 或者都失败**, 这些 sql 语句的执行是一致的,作为一个整体执行

2. 在什么时候想到使用事务

   1. **当我的操作,涉及得到多个表,或者是多个 sql 语句的 insert,update,delete**
   2. 需要保证这些语句都是成功才能完成我的功能,或者都失败,保证操作是符合要求的
   3. 在 java 代码中写程序,控制事务,此时事务应该放在那里呢？

   - service 类的业务方法上,因为业务方法会调用多个 dao 方法,执行多个 sql 语句

3. 通常使用 JDBC 访问数据库, 还是 mybatis 访问数据库怎么处理事务?

   1. jdbc 访问数据库,处理事务, `Connection conn ; conn.commit(); conn.rollback();`
   2. mybatis 访问数据库,处理事务, `SqlSession.commit(); SqlSession.rollback();`
   3. hibernate 访问数据库,处理事务, `Session.commit(); Session.rollback();`

4. 3 问题中事务的处理方式,有什么不足

   1. 不同的数据库访问技术,处理事务的对象,方法不同
   2. 需要了解不同数据库访问技术使用事务的原理
   3. 掌握多种数据库中事务的处理逻辑什么时候提交事务,什么时候回顾事务, 处理事务的多种方法
   4. 总结: 就是多种数据库的访问技术,有不同的事务处理的机制,对象,方法

## 2. Spring 中的事务管理

- spring 提供一种处理事务的统一模型, 能使用统一步骤,方式完成多种不同数据库访问技术的事务处理

  - 使用 spring 的事务处理机制,可以完成 mybatis 访问数据库的事务处理
  - 使用 spring 的事务处理机制,可以完成 hibernate 访问数据库的事务处理

- 处理事务,需要怎么做,做什么

  - spring 处理事务的模型,使用的步骤都是固定的把事务使用的信息提供给 spring 就可以了
  - 事务内部提交,回滚事务,**使用的\*\***事务管理器对象\*\*,代替你完成 commit,rollback

    - 事务管理器是一个接口和他的众多实现类

      - 接口: PlatformTransactionManager ,定义了事务重要方法 commit ,rollback
      - 实现类: spring 把每一种数据库访问技术对应的事务处理类都创建好了

        - mybatis 访问数据库---spring 创建好的是 DataSourceTransactionManager
        - hibernate 访问数据库----spring 创建的是 HibernateTransactionManager

  - 怎么使用: **你需要告诉 spring 你用是那种数据库的访问技术**,怎么告诉 spring 呢？

    - 声明数据库访问技术对应的事务管理器实现类, 在 spring 的配置文件中使用`<bean>`声明就可以了

    - 例如,你要使用 mybatis 访问数据库,你应该在 xml 配置文件中配置`<bean id=“xxx" class="...DataSourceTransactionManager">`

  - 你的业务方法需要什么样的事务,**说明需要事务的类型**

    - 说明方法需要的事务:

      - 事务的隔离级别: 有 4 个值

        - DEFAULT: 采用 DB 默认的事务隔离级别 MySql 的默认为 REPEATABLE_READ； Oracle 默认为 READ_COMMITTED
        - READ_UNCOMMITTED: 读未提交未解决任何并发问题
        - READ_COMMITTED: 读已提交解决脏读,存在不可重复读与幻读
        - REPEATABLE_READ: 可重复读解决脏读、不可重复读,存在幻读
        - SERIALIZABLE: 串行化不存在并发问题

    - 事务的超时时间: 表示一个方法最长的执行时间,如果方法执行时超过了时间,事务就回滚单位是秒, 整数值, 默认是 -1.
    - 事务的传播行为 : 控制业务方法是不是有事务的, 是什么样的事务的

      - 7 个传播行为,表示你的业务方法调用时,事务在方法之间是如果使用的
      - **PROPAGATION_REQUIRED, PROPAGATION_REQUIRES_NEW, PROPAGATION_SUPPORTS(**需要掌握**)**
      - PROPAGATION_MANDATORY, PROPAGATION_NESTED, PROPAGATION_NEVER, PROPAGATION_NOT_SUPPORTED

  - 提交事务,回滚事务的时机

    - 当你的业务方法,执行成功,没有异常抛出,当方法执行完毕,spring 在方法执行后提交事务事务管理器 commit
    - 当你的业务方法抛出运行时异常或 ERROR, spring 执行回滚,调用事务管理器的 rollback

      - 运行时异常的定义: RuntimeException 和他的子类都是运行时异常, 例如 NullPointException , NumberFormatException

    - 当你的业务方法抛出非运行时异常, 主要是受查异常时,提交事务

      - 受查异常: 在你写代码中,必须处理的异常例如 IOException, SQLException

- 总结 spring 的事务

  - 管理事务的是 事务管理和他的实现类
  - spring 的事务是一个统一模型

    - 指定要使用的事务管理器实现类,使用`<bean>`
    - 指定哪些类,哪些方法需要加入事务的功能
    - 指定方法需要的隔离级别,传播行为,超时

## 3. 模拟事务环境搭建

### 1. dao 层

```java
public interface GoodsDao {
    // 更新库存
    // goods表示本次用户购买的商品信息, id, 购买数量
    int updateGoods(Goods goods);

    // 查询商品的信息
    Goods selectGoods(Integer id);
}
```

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.bjpowernode.dao.GoodsDao">
  <select id="selectGoods" resultType="com.bjpowernode.domain.Goods">
    select id, name, amount, price
    from springtrans.goods
    where id = #{gid}
  </select>

  <update id="updateGoods">
    update springtrans.goods
    set amount = amount - #{amount}
    where id = #{id}
  </update>
</mapper>
```

```java
public interface SaleDao {
    // 增加销售记录
    int insertSale(Sale sale);
}
```

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.bjpowernode.dao.SaleDao">
  <insert id="insertSale">
    insert into springtrans.sale(gid, nums)
    values (#{gid}, #{nums})
  </insert>
</mapper>
```

### 2. 实体类

```java
@Data
public class Goods {
    private Integer id;
    private String name;
    private Integer amount;
    private Float price;
}
```

```java
@Data
public class Sale {
    private Integer id;
    private Integer gid;
    private Integer nums;
}
```

### 3. service 层

```java
public interface BuyGoodsService {

    // 购买商品的方法, goodsId: 购买商品的编号, nums: 购买的数量
    void buy(Integer goodsId, Integer nums);
}
```

```java
public class BuyGoodsServiceImpl implements BuyGoodsService {

  private SaleDao saleDao;
  private GoodsDao goodsDao;

  @Override
  public void buy(Integer goodsId, Integer nums) {
    System.out.println("=====buy方法的开始====");
    // 记录销售信息,向sale表添加记录
    Sale sale = new Sale();
    sale.setGid(goodsId);
    sale.setNums(nums);
    saleDao.insertSale(sale);

    // 更新库存
    Goods goods = goodsDao.selectGoods(goodsId);
    if (goods == null) {
      // 商品不存在
      throw new NullPointerException("编号是: " + goodsId + ",商品不存在");
    } else if (goods.getAmount() < nums) {
      // 商品库存不足
      throw new NotEnoughException("编号是: " + goodsId + ",商品库存不足");
    }
    // 修改库存了
    Goods buyGoods = new Goods();
    buyGoods.setId(goodsId);
    buyGoods.setAmount(nums);
    goodsDao.updateGoods(buyGoods);
    System.out.println("=====buy方法的完成====");
  }

  public void setSaleDao(SaleDao saleDao) {
    this.saleDao = saleDao;
  }

  public void setGoodsDao(GoodsDao goodsDao) {
    this.goodsDao = goodsDao;
  }
}
```

### 4. 配置文件

1. jdbc.properties

   ```properties
   jdbc.url=jdbc:mysql://localhost:3306/springtrans
   jdbc.username=root
   jdbc.passwd=root
   jdbc.max=30
   ```

2. mybatis.xml

   ```xml
   <?xml version="1.0" encoding="UTF-8" ?>
   <!DOCTYPE configuration
           PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
           "http://mybatis.org/dtd/mybatis-3-config.dtd">
   <configuration>
   <!--设置别名-->
   <typeAliases>
       <!--name:实体类所在的包名
               表示com.bjpowernode.domain包中的列名就是别名
               你可以使用Student表示com.bjpowenrode.domain.Student
           -->
       <package name="com.bjpowernode.domain"/>
   </typeAliases>
   <!-- sql mapper(sql映射文件)的位置-->
   <mappers>
       <!--
           name: 是包名, 这个包中的所有mapper.xml一次都能加载
           -->
       <package name="com.bjpowernode.dao"/>
   </mappers>
   </configuration>
   ```

3. applicationContext.xml

   ```xml
   <?xml version="1.0" encoding="UTF-8"?>
   <beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
                           http://www.springframework.org/schema/beans/spring-beans.xsd
                           http://www.springframework.org/schema/context
                           https://www.springframework.org/schema/context/spring-context.xsd">
    <!--
       把数据库的配置信息,写在一个独立的文件,编译修改数据库的配置内容
       spring知道jdbc.properties文件的位置
    -->
   <context:property-placeholder location="classpath:jdbc.properties"/>
   <!--声明数据源DataSource, 作用是连接数据库的-->
   <bean id="myDataSource" class="com.alibaba.druid.pool.DruidDataSource"
           init-method="init" destroy-method="close">
       <!--set注入给DruidDataSource提供连接数据库信息 -->
       <!--    使用属性配置文件中的数据,语法 ${key} -->
       <property name="url" value="${jdbc.url}"/><!--setUrl()-->
       <property name="username" value="${jdbc.username}"/>
       <property name="password" value="${jdbc.passwd}"/>
       <property name="maxActive" value="${jdbc.max}"/>
   </bean>
    <!--声明的是mybatis中提供的SqlSessionFactoryBean类,这个类内部创建SqlSessionFactory的
           SqlSessionFactory  sqlSessionFactory = new ..
    -->
   <bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean">
       <!--set注入,把数据库连接池付给了dataSource属性-->
       <property name="dataSource" ref="myDataSource"/>
       <!--mybatis主配置文件的位置
           configLocation属性是Resource类型,读取配置文件
           它的赋值,使用value,指定文件的路径,使用classpath:表示文件的位置
           -->
       <property name="configLocation" value="classpath:mybatis.xml"/>
   </bean>
    <!--创建dao对象,使用SqlSession的getMapper（StudentDao.class）
           MapperScannerConfigurer:在内部调用getMapper()生成每个dao接口的代理对象
    -->
   <bean class="org.mybatis.spring.mapper.MapperScannerConfigurer">
       <!--指定SqlSessionFactory对象的id-->
       <property name="sqlSessionFactoryBeanName" value="sqlSessionFactory"/>
       <!--指定包名, 包名是dao接口所在的包名
               MapperScannerConfigurer会扫描这个包中的所有接口,把每个接口都执行
               一次getMapper()方法,得到每个接口的dao对象
               创建好的dao对象放入到spring的容器中的 dao对象的默认名称是 接口名首字母小写
           -->
       <property name="basePackage" value="com.bjpowernode.dao"/>
   </bean>
   <!--声明service-->
   <bean id="buyService" class="com.bjpowernode.service.impl.BuyGoodsServiceImpl">
       <property name="goodsDao" ref="goodsDao"/>
       <property name="saleDao" ref="saleDao"/>
   </bean>
   </beans>
   ```

## 4. 事务处理

### 1. spring 框架中提供的事务处理方案

1. 适合中小项目使用的, 注解方案
2. spring 框架自己用 aop 实现给业务方法增加事务的功能, 使用`@Transactional`注解增加事务
3. `@Transactional`注解是 spring 框架自己注解,放在 public 方法的上面,表示当前方法具有事务
4. **可以给注解的属性赋值,表示具体的隔离级别,传播行为,异常信息等等**

使用`@Transactional`的步骤:

- 需要声明事务管理器对象`<bean id="xx" class="DataSourceTransactionManager">`

```xml
<!--使用spring的事务处理-->
<!--1. 声明事务管理器-->
<bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
  <!--连接的数据库, 指定数据源-->
  <property name="dataSource" ref="myDataSource" />
</bean>
```

- 开启事务注解驱动, 告诉 spring 框架,我要使用注解的方式管理事务

```xml
<!--2. 开启事务注解驱动,告诉spring使用注解管理事务,创建代理对象
           transaction-manager:事务管理器对象的id
    -->
<tx:annotation-driven transaction-manager="transactionManager" />
```

- spring 使用 aop 机制,创建`@Transactional`所在的类代理对象,给方法加入事务的功能

spring 给业务方法加入事务:

- 在你的业务方法执行之前,先开启事务,在业务方法之后提交或回滚事务,使用 aop 的环绕通知
- 在你的方法的上面加入`@Trancational`

在 applicationContext.xml 中声明和开启事务

```xml
<!--使用spring的事务处理-->
<!--1. 声明事务管理器-->
<bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
  <!--连接的数据库, 指定数据源-->
  <property name="dataSource" ref="myDataSource" />
</bean>

<!--2. 开启事务注解驱动,告诉spring使用注解管理事务,创建代理对象
           transaction-manager:事务管理器对象的id
    -->
<tx:annotation-driven transaction-manager="transactionManager" />
```

给 BuyGoodsServiceImpl 中的 buy()方法添加事务控制

```java
/**
   * rollbackFor:表示发生指定的异常一定回滚. 处理逻辑是:  1) spring框架会首先检查方法抛出的异常是不是在rollbackFor的属性值中
   * 如果异常在rollbackFor列表中,不管是什么类型的异常,一定回滚 2)
   * 如果你的抛出的异常不在rollbackFor列表中,spring会判断异常是不是RuntimeException, 如果是一定回滚
   */
/* @Transactional(
          propagation = Propagation.REQUIRED,
          isolation = Isolation.DEFAULT,
          readOnly = false,
          rollbackFor = {
                  NullPointerException.class,  NotEnoughException.class
          }
  )*/

// 使用的是事务控制的默认值, 默认的传播行为是REQUIRED,默认的隔离级别DEFAULT
// 默认抛出运行时异常,回滚事务
@Transactional
@Override
public void buy(Integer goodsId, Integer nums) {
    System.out.println("=====buy方法的开始====");
    // 记录销售信息,向sale表添加记录
    Sale sale = new Sale();
    sale.setGid(goodsId);
    sale.setNums(nums);
    saleDao.insertSale(sale);

    // 更新库存
    Goods goods = goodsDao.selectGoods(goodsId);
    if (goods == null) {
        // 商品不存在
        throw new NullPointerException("编号是: " + goodsId + ",商品不存在");
    } else if (goods.getAmount() < nums) {
        // 商品库存不足
        throw new NotEnoughException("编号是: " + goodsId + ",商品库存不足");
    }
    // 修改库存了
    Goods buyGoods = new Goods();
    buyGoods.setId(goodsId);
    buyGoods.setAmount(nums);
    goodsDao.updateGoods(buyGoods);
    System.out.println("=====buy方法的完成====");
}
```

### 2. 使用 aspectj 的 aop 配置管理事务

适合大型项目,有很多的类,方法,需要大量的配置事务,使用 aspectj 框架功能,在 spring 配置文件中声明类,方法需要的事务这种方式业务方法和事务配置完全分离

实现步骤: 都是在 xml 配置文件中实现

1. 要使用的是 aspectj 框架,需要加入依赖

   ```xml
   <dependency>
       <groupId>org.springframework</groupId>
       <artifactId>spring-aspects</artifactId>
       <version>5.2.5.RELEASE</version>
   </dependency>
   ```

2. 声明事务管理器对象

   ```xml
   <!--声明式事务处理: 和源代码完全分离的-->
   <!--1.声明事务管理器对象-->
   <bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
     <property name="dataSource" ref="myDataSource"/>
   </bean>
   ```

3. 声明方法需要的事务类型（配置方法的事务属性【隔离级别,传播行为,超时】）

   ```xml
    <!--2.声明业务方法它的事务属性（隔离级别,传播行为,超时时间）
           id:自定义名称,表示 <tx:advice> 和 </tx:advice>之间的配置内容的
           transaction-manager:事务管理器对象的id
    -->
   <tx:advice id="myAdvice" transaction-manager="transactionManager">
   <!--tx:attributes: 配置事务属性-->
   <tx:attributes>
       <!--tx:method: 给具体的方法配置事务属性,method可以有多个,分别给不同的方法设置事务属性
                   name:方法名称,1）完整的方法名称,不带有包和类
                               2）方法可以使用通配符,* 表示任意字符
                   propagation: 传播行为,枚举值
                   isolation: 隔离级别
                   rollback-for: 你指定的异常类名,全限定类名 发生异常一定回滚
               -->
       <tx:method name="buy" propagation="REQUIRED" isolation="DEFAULT"
               rollback-for="java.lang.NullPointerException,com.bjpowernode.excep.NotEnoughException"/>

       <!--使用通配符,指定很多的方法-->
       <tx:method name="add*" propagation="REQUIRES_NEW"/>
       <!--指定修改方法-->
       <tx:method name="modify*"/>
       <!--删除方法-->
       <tx:method name="remove*"/>
       <!--查询方法,query,search,find-->
       <tx:method name="*" propagation="SUPPORTS" read-only="true"/>
   </tx:attributes>
   </tx:advice>
   ```

4. 配置 aop: 指定哪些哪类要创建代理

   ```xml
   <!--配置aop-->
   <aop:config>
    <!--配置切入点表达式: 指定哪些包中类,要使用事务
               id:切入点表达式的名称,唯一值
               expression: 切入点表达式,指定哪些类要使用事务,aspectj会创建代理对象

               com.bjpowernode.service
               com.crm.service
               com.service
    -->
   <aop:pointcut id="servicePt" expression="execution(* *..service..*.*(..))"/>

    <!--配置增强器: 关联adivce和pointcut
           advice-ref:通知,上面tx:advice哪里的配置
           pointcut-ref: 切入点表达式的id
    -->
   <aop:advisor advice-ref="myAdvice" pointcut-ref="servicePt"/>
   </aop:config>
   ```

5. BuyGoodsServiceImpl 中的 buy()方法

   ```java
   @Override
   public void buy(Integer goodsId, Integer nums) {
       System.out.println("=====buy方法的开始====");
       // 记录销售信息,向sale表添加记录
       Sale sale = new Sale();
       sale.setGid(goodsId);
       sale.setNums(nums);
       saleDao.insertSale(sale);

       // 更新库存
       Goods goods = goodsDao.selectGoods(goodsId);
       if (goods == null) {
           // 商品不存在
           throw new NullPointerException("编号是: " + goodsId + ",商品不存在");
       } else if (goods.getAmount() < nums) {
           // 商品库存不足
           throw new NotEnoughException("编号是: " + goodsId + ",商品库存不足");
       }
       // 修改库存了
       Goods buyGoods = new Goods();
       buyGoods.setId(goodsId);
       buyGoods.setAmount(nums);
       goodsDao.updateGoods(buyGoods);
       System.out.println("=====buy方法的完成====");
   }
   ```
