---
icon: note
date: 2022-09-06
order: 8
category:
  - Spring
---

# 8. 代理模式

[**_原文_**](https://www.cnblogs.com/aduner/p/14646877.html#定义)

在有些情况下，一个客户不能或者不想直接访问另一个对象，这时需要找一个中介帮忙完成某项任务，这个中介就是代理对象。

例如，购买火车票不一定要去火车站买，可以通过 12306 网站或者去火车票代售点买。又如找女朋友、找保姆、找工作等都可以通过找中介完成。

## 定义

由于某些原因需要给某对象提供一个代理以控制对该对象的访问。

访问对象**不适合或者不能直接引用**目标对象，**代理对象**作为**访问对象**和**目标对象**之间的**中介**。

## 代理模式的主要角色

- 抽象角色（Subject）：通过接口或抽象类声明真实主题和代理对象实现的业务方法。
- 真实角色（Real Subject）：实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。
- 代理（Proxy）：提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。
- 客户 : 使用代理角色来进行一些操作 .

## 优点

- 代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用
- 代理对象可以扩展目标对象的功能
- 代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度，增加了程序的可扩展性

## 缺点

- 冗余，由于代理对象要实现与目标对象一致的接口，会产生过多的代理类。
- 系统设计中类的数量增加，变得难以维护。

使用动态代理方式，可以有效避免以上的缺点

## 静态代理

静态代理其实就是最基础、最标准的代理模式实现方案。

1. 接口 Rent . java 即抽象角色

   ```java
   //抽象角色：租房
   public interface Rent {
   public void rent();
   }public interface Rent {   public void rent();}
   ```

2. 真实角色 Landlord . java 即真实角色

   ```java
   //真实角色: 房东，房东要出租房子
   public class Landlord implements Rent{
   public void rent() {
       System.out.println("房屋出租");
   }
   }
   ```

3. 代理角色 Proxy . java 即代理

   ```java
   //代理角色：中介
   public class Proxy implements Rent {

   private Landlord landlord;
   public Proxy() { }
   public Proxy(Landlord landlord) {
       this.landlord = landlord;
   }
   //租房
   public void rent(){
       seeHouse();
       landlord.rent();
       fare();
   }
   //看房
   public void seeHouse(){
       System.out.println("带房客看房");
   }
   //收中介费
   public void fare(){
       System.out.println("收中介费");
   }
   }
   ```

4. 客户端访问代理角色 Client . java 即客户

   ```java
   //客户类，一般客户都会去找代理！
   public class Client {
   public static void main(String[] args) {
       //房东要租房
       Landlord landlord = new Landlord();
       //中介帮助房东
       Proxy proxy = new Proxy(landlord);
       //客户找中介
       proxy.rent();
   }
   }
   ```

**结果：**

![代理模式](https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/202209052233182.png)

在这个过程中，客户接触的是中介，看不到房东，但是依旧租到了房东的房子。同时房东省了心，客户省了事。

## 动态代理

动态代理的出现就是为了解决传统静态代理模式的中的缺点。

具备代理模式的优点的同时，巧妙的解决了静态代理代码冗余，难以维护的缺点。

在 Java 中常用的有如下几种方式：

- JDK 原生动态代理: 基于接口
- cglib 动态代理: 基于类
- javasist 动态代理: java 字节码实现

### JDK 原生动态代理

**例子:**

1. 首先实现一个 InvocationHandler，方法调用会被转发到该类的 invoke()方法。
2. 然后在需要使用 Rent 的时候，通过 JDK 动态代理获取 Rent 的代理对象。

```java
public class RentInvocationHandler implements InvocationHandler {
  private Object target;

  public RentInvocationHandler(Object target) {
    this.target = target;
  }

  @Override
  public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
    return method.invoke(target, args);
  }

  /**
   * 动态获取代理
   *
   * @return 代理对象
   */
  public Object getProxy() {
    return Proxy.newProxyInstance(
        // 核心关键
        this.getClass().getClassLoader(), target.getClass().getInterfaces(), this);
  }
}
```

客户使用动态代理调用

```java
public class Client {
  public static void main(String[] args) {
    Landlord landlord = new Landlord();
    //代理实例的调用处理程序
    RentInvocationHandler pih = new RentInvocationHandler(landlord);
    //动态生成对应的代理类！
    Rent proxy = (Rent)pih.getProxy();
    proxy.rent();
  }
}
```

### 分析

上述代码的核心关键是`Proxy.newProxyInstance`方法，该方法会根据指定的参数动态创建代理对象。

它三个参数的意义如下：

1. `loader`，指定代理对象的类加载器
2. `interfaces`，代理对象需要实现的接口，可以同时指定多个接口
3. `handler`，方法调用的实际处理者，代理对象的方法调用都会转发到这里

`Proxy.newProxyInstance`会返回一个实现了指定接口的代理对象，对该对象的所有方法调用都会转发给`InvocationHandler.invoke()`方法。

因此，在`invoke()`方法里我们可以加入任何逻辑，比如修改方法参数，加入日志功能、安全检查功能等等等等……

### 小结

显而易见，对于静态代理而言，我们需要**手动编写代码**让**代理**实现**抽象角色**的接口。

而在动态代理中，我们可以让程序在运行的时候**自动在内存中创建**一个实现**抽象角色接口**的代理，而不需要去单独定义这个类，代理对象是在程序运行时产生的，而不是编译期。

对于从 Object 中继承的方法，JDK Proxy 会把`hashCode()`、`equals()`、`toString()`这三个非接口方法转发给`InvocationHandler`，其余的 Object 方法则不会转发。
