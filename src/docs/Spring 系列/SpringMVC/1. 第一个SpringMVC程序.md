---
icon: note
date: 2022-09-15
order: 1
category:
  - SpringMVC
---

# 1. 第一个 SpringMVC 程序

## 实现步骤

> 1. 新建 web maven 工程
> 2. 加入依赖
>    spring-webmvc 依赖(间接把 spring 的依赖都加入到项目), jsp 依赖, servlet 依赖
> 3. **重点**：在 web.xml 中注册 springmvc 框架的核心对象 DispatcherServlet
>
>    1. DispatcherServlet 叫做中央调度器， 是一个 servlet， 它的父类是继承 HttpServlet
>    2. DispatcherServlet 页叫做**前端控制器（front controller）**
>    3. DispatcherServlet 负责接收用户提交的请求， 调用其它的控制器对象，并把请求的处理结果显示给用户
>
> 4. 创建一个发起请求的页面 index.jsp
> 5. 创建控制器(处理器)类
>
>    1. 在类的上面加入@Controller 注解，创建对象，并放入到 springmvc 容器中
>    2. 在类中的方法上面加入@RequestMapping 注解。
>
> 6. 创建一个作为结果的 jsp，显示请求的处理结果。
> 7. 创建 springmvc 的配置文件（spring 的配置文件一样）
>
>    1. 声明组件扫描器， 指定@Contorller 注解所在的包名
>    2. 声明视图解析器。帮助处理视图的。

三个依赖:

```xml
<dependency>
  <groupId>org.springframework</groupId>
  <artifactId>spring-webmvc</artifactId>
  <version>5.3.8</version>
</dependency>
<!-- https://mvnrepository.com/artifact/javax.servlet/javax.servlet-api -->
<dependency>
  <groupId>javax.servlet</groupId>
  <artifactId>javax.servlet-api</artifactId>
  <version>4.0.1</version>
  <scope>provided</scope>
</dependency>
<!-- https://mvnrepository.com/artifact/javax.servlet.jsp/jsp-api -->
<dependency>
  <groupId>javax.servlet.jsp</groupId>
  <artifactId>jsp-api</artifactId>
  <version>2.2.1-b03</version>
  <scope>provided</scope>
</dependency>
```

web.xml 中的配置:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"
         version="4.0">
  <!--
    声明，注册springmvc的核心对象DispatcherServlet
        需要在tomcat服务器启动后，创建DispatcherServlet对象的实例。
        为什么要创建DispatcherServlet对象的实例呢？
        因为DispatcherServlet在他的创建过程中， 会同时创建springmvc容器对象，
        读取springmvc的配置文件，把这个配置文件中的对象都创建好， 当用户发起
        请求时就可以直接使用对象了。

        servlet的初始化会执行init（）方法。 DispatcherServlet在init（）中{
           //创建容器，读取配置文件
           WebApplicationContext ctx = new ClassPathXmlApplicationContext("springmvc.xml");
           //把容器对象放入到ServletContext中
           getServletContext().setAttribute(key, ctx);
        }

        启动tomcat报错，读取这个文件 /WEB-INF/springmvc-servlet.xml（/WEB-INF/myweb-servlet.xml）
        springmvc创建容器对象时，读取的配置文件默认是/WEB-INF/<servlet-name>-servlet.xml .
    -->
  <servlet>
    <servlet-name>myweb</servlet-name>
    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>

    <!--自定义springmvc读取的配置文件的位置-->
    <init-param>
      <!--springmvc的配置文件的位置的属性-->
      <param-name>contextConfigLocation</param-name>
      <!--指定自定义文件的位置-->
      <param-value>classpath:springmvc.xml</param-value>
    </init-param>

    <!--在tomcat启动后，创建Servlet对象
            load-on-startup:表示tomcat启动后创建对象的顺序。它的值是整数，数值越小，
                            tomcat创建对象的时间越早。 大于等于0的整数。
    -->
    <load-on-startup>1</load-on-startup>
  </servlet>

  <servlet-mapping>
    <servlet-name>myweb</servlet-name>
    <!--
            使用框架的时候， url-pattern可以使用两种值
            1. 使用扩展名方式， 语法 *.xxxx , xxxx是自定义的扩展名。 常用的方式 *.do, *.action, *.mvc等等
               不能使用 *.jsp
               http://localhost:8080/myweb/some.do
               http://localhost:8080/myweb/other.do

            2.使用斜杠 "/"
        -->
    <url-pattern>*.do</url-pattern>
  </servlet-mapping>
</web-app>
```

发起请求的页面 index.jsp:

```jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
  <html>
    <head>
      <title>$Title$</title>
    </head>
    <body>
      <p>第一个springmvc项目</p>
      <p><a href="some.do">发起some.do请求</a></p>
    </body>
  </html>
```

控制器(处理器)类:

`@Controller`:

创建处理器对象，对象放在 springmvc 容器中。 位置：在类的上面 和 Spring 中讲的@Service ,@Component

能处理请求的都是控制器（处理器）： MyController 能处理请求， 叫做**后端控制器（back controller）**

没有注解之前，需要实现各种不同的接口才能做控制器使用

处理用户提交的请求:

> springmvc 中是使用方法来处理的。
>
> 方法是自定义的，可以有多种返回值，多种参数，方法名称自定义
>
> 例如: 使用 doSome 方法处理 some.do 请求

`@RequestMapping`:

请求映射，作用是把一个请求地址和一个方法绑定在一起。 一个请求指定一个方法处理。

属性：value

> 是一个 String，表示请求的 uri 地址（some.do）。
>
> value 的值必须是唯一的， 不能重复。 在使用时，推荐地址以“/” 开头

位置：

> 1. 在方法的上面(常用的)
> 2. 在类的上面

说明：

> 使用 RequestMapping 修饰的方法叫做处理器方法或者控制器方法
>
> 使用@RequestMapping 修饰的方法可以处理请求的, 类似 Servlet 中的 doGet, doPost

返回值: ModelAndView

> 表示本次请求的处理结果
>
> Model: 数据，请求处理完成后，要显示给用户的数据 View: 视图， 比如 jsp 等等。

```java
@Controller
public class MyController {
    @RequestMapping(value = {"/some.do"})
    public ModelAndView doSome() { // doGet()--service请求处理
        // 处理some.do请求了。 相当于service调用处理完成了。
        ModelAndView mv = new ModelAndView();
        // 添加数据， 框架在请求的最后把数据放入到request作用域。
        // request.setAttribute("msg","欢迎使用springmvc做web开发");
        mv.addObject("msg", "欢迎使用springmvc做web开发");
        mv.addObject("fun", "执行的是doSome方法");

        // 指定视图, 指定视图的完整路径
        // 框架对视图执行的forward操作， request.getRequestDispather("/show.jsp).forward(...)
        mv.setViewName("/show.jsp");

        // 返回mv
        return mv;
    }
}
```

显示请求的处理结果:

```jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
  <html>
    <head>
      <title>Title</title>
    </head>
    <body>
      <h3>show.jsp从request作用域获取数据</h3><br/>
      <h3>msg数据：${msg}</h3><br/>
      <h3>fun数据：${fun}</h3>
    </body>
  </html>
```

springmvc 配置文件:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd">

  <!--声明组件扫描器-->
  <context:component-scan base-package="com.bjpowernode.controller" />
</beans>
```

结果:

![20210817170300856_28388](https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/202209151554377.png)

![20210817170319036_5564](https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/202209151554656.png)

## springmvc 请求的处理流程

> 1. 发起 some.do
> 2. tomcat(web.xml--url-pattern 知道 \*.do 的请求给 DispatcherServlet)
> 3. DispatcherServlet（根据 springmvc.xml 配置知道 some.do---doSome()）
> 4. DispatcherServlet 把 some.do 转发个 MyController.doSome()方法
> 5. 框架执行 doSome（）把得到 ModelAndView 进行处理， 转发到 show.jsp

上面过程简化

some.do---DispatcherServlet---MyController

![mvc流程](https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/202209151554017.png)

## springmvc 执行过程源代码分析

> 1. tomcat 启动，创建容器的过程
>
>    1. 通过 load-on-start 标签指定的 1，创建 DispatcherServlet 对象，
>    2. DispatcherServlet 它的父类是继承 HttpServlet 的， 它是一个 serlvet， 在被创建时，会执行 init（）方法
>
>       1. 在 init（）方法中
>       2. 创建容器，读取配置文件
>       3. `WebApplicationContext ctx = new ClassPathXmlApplicationContext("springmvc.xml");`
>       4. 把容器对象放入到 ServletContext 中
>       5. `getServletContext().setAttribute(key, ctx);`
>
>    3. 上面创建容器作用：
>
>       1. 创建@controller 注解所在的类的对象
>       2. 创建 MyController 对象, 将这个对象放入到 springmvc 的容器中， 容器是 map ， 类似 map.put("myController",MyController 对象)
>
> 1. 请求的处理过程
>
>    1. 执行 servlet 的 service()
>
>    1. `protected void service(HttpServletRequest request, HttpServletResponse response)`
>    1. `protected void doService(HttpServletRequest request, HttpServletResponse response)`
>    1. `DispatcherServlet.doDispatch(request, response){ 调用MyController的.doSome()方法 }`

doDispatch：springmvc 中 DispatcherServlet 的核心方法， 所有的请求都在这个方法中完成的。
