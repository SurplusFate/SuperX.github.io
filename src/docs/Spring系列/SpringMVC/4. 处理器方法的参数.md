---
icon: note
date: 2022-09-15
order: 4
category:
  - SpringMVC
---

# 4. 处理器方法的参数

> 1. HttpServletRequest
> 2. HttpServletResponse
> 3. HttpSession
>
> 这三个参数使用方式和 servlet 中的 doGetdoPost 方法类似

```java
@RequestMapping(value = "/some.do", method = RequestMethod.GET)
public ModelAndView doSome(
    HttpServletRequest request, HttpServletResponse response, HttpSession session) {
    ModelAndView mv = new ModelAndView();
    mv.addObject("msg", "欢迎使用springmvc做web开发");
    mv.addObject("fun", "执行的是doSome方法");
    mv.setViewName("show");
    // 返回mv
    return mv;
}
```

## 用户提交的数据

> 接收用户提交的参数：
>
> 1. 逐个接收
> 2. 对象接收

### 逐个接收

表单:

```html
<p>提交参数给Controller</p>
<form action="receiveproperty.do" method="post">
  姓名：<input type="text" name="name" /> <br />
  年龄：<input type="text" name="age" /> <br />
  <input type="submit" value="提交参数" />
</form>
```

处理器方法:

> 逐个接收请求参数：
>
> 要求：
>
> 处理器（控制器）方法的形参名和请求中参数名必须一致。
>
> 同名的请求参数赋值给同名的形参
>
> 框架接收请求参数
>
> 1. 使用 request 对象接收请求参数
>
>    `String trName = request.getParameter("name");`
>
>    `String strAge = request.getParameter("age");`
>
> 2. springmvc 框架通过 DispatcherServlet 调用 MyController 的 doSome()方法
>
>    调用方法时，按名称对应，把接收的参数赋值给形参
>
>    doSome（strName，Integer.valueOf(strAge)）
>
>    框架会提供类型转换的功能，能把 String 转为 int ，long ， float， double 等类型。
>
>    可能的异常:
>
>    400 状态码是客户端错误， 表示提交请求参数过程中，发生了问题。(类型不匹配, 无法强转)

```java
@RequestMapping(value = "/receiveproperty.do")
public ModelAndView doSome(String name, Integer age) {
    // 可以在方法中直接使用 name ， age
    // 处理some.do请求了。 相当于service调用处理完成了。
    ModelAndView mv = new ModelAndView();
    mv.addObject("myname", name);
    mv.addObject("myage", age);
    // show是视图文件的逻辑名称（文件名称）
    mv.setViewName("show");
    return mv;
}
```

::: tip

在提交请求参数时，get 请求方式中文没有乱码。

使用 post 方式提交请求，中文有乱码，需要使用过滤器处理乱码的问题。

过滤器可以自定义，也可使用框架中提供的过滤器 CharacterEncodingFilter

:::

在 web.xml 中配置过滤器:

```xml
<!--注册声明过滤器，解决post请求乱码的问题-->
<filter>
  <filter-name>characterEncodingFilter</filter-name>
  <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>
  <!--设置项目中使用的字符编码-->
  <init-param>
    <param-name>encoding</param-name>
    <param-value>utf-8</param-value>
  </init-param>
  <!--强制请求对象（HttpServletRequest）使用encoding编码的值-->
  <init-param>
    <param-name>forceRequestEncoding</param-name>
    <param-value>true</param-value>
  </init-param>
  <!--强制应答对象（HttpServletResponse）使用encoding编码的值-->
  <init-param>
    <param-name>forceResponseEncoding</param-name>
    <param-value>true</param-value>
  </init-param>
</filter>
<filter-mapping>
  <filter-name>characterEncodingFilter</filter-name>
  <!--
     /*:表示强制所有的请求先通过过滤器处理。
   -->
  <url-pattern>/*</url-pattern>
</filter-mapping>
```

**@RequestParam 注解:**

请求中参数名和处理器方法的形参名不一样

@RequestParam: 逐个接收请求参数中， 解决请求中参数名形参名不一样的问题

属性：

> 1. value 请求中的参数名称
> 2. required
>
> 3. 是一个 boolean，默认是 true
> 4. true：表示请求中必须包含此参数。

位置：

> 在处理器方法的形参定义的前面

```java
@RequestMapping(value = "/receiveparam.do")
public ModelAndView receiveParam(
    @RequestParam(value = "rname", required = false) String name,
    @RequestParam(value = "rage", required = false) Integer age) {
    System.out.println("doSome, name=" + name + "   age=" + age);
    // 可以在方法中直接使用 name ， age 处理some.do请求。 相当于service调用处理完成了。
    ModelAndView mv = new ModelAndView();
    mv.addObject("myname", name);
    mv.addObject("myage", age);
    mv.setViewName("show");
    return mv;
}
```

### 对象接收

实体类:

```java
@Data
public class Student {
    // 属性名和请求中参数名一样
    private String name;
    private Integer age;
}
```

处理器方法:

处理器方法形参是 java 对象， 这个对象的属性名和请求中的参数名一样; 框架会创建形参的 java 对象，给属性赋值。 请求中的参数是 name，框架会调用 setName()

```java
@RequestMapping(value = "/receiveobject.do")
public ModelAndView receiveParam(Student myStudent) {
    System.out.println(
        "receiveParam, name=" + myStudent.getName() + "   age=" + myStudent.getAge());
    ModelAndView mv = new ModelAndView();
    mv.addObject("myname", myStudent.getName());
    mv.addObject("myage", myStudent.getAge());
    mv.addObject("mystudent", myStudent);
    mv.setViewName("show");
    return mv;
}
```
