

# 伙伴匹配系统

## 领域模型中的实体类

**VO（View Object）**：视图对象，用于展示层，它的作用是把某个指定页面（或组件）的所有数据封装起来。
**DTO（Data Transfer Object）**：数据传输对象，这个概念来源于J2EE的设计模式，原来的目的是为了EJB的分布式应用提供粗粒度的数据实体，以减少分布式调用的次数，从而提高分布式调用的性能和降低网络负载，但在这里，我泛指用于展示层与服务层之间的数据传输对象。
**DO（Domain Object）**：领域对象，就是从现实世界中抽象出来的有形或无形的业务实体。
**PO（PersistentObject）**：持久化对象，它跟持久层（通常是关系型数据库）的数据结构形成一一对应的映射关系，如果持久层是关系型数据库，那么，数据表中的每个字段（或若干个）就对应PO的一个（或若干个）属性。

## 通过标签查询全部用户

1. 允许用户传入多个标签，多个标签都存在才搜索出来 and。like '%Java%' and like '%C++%'。
2. 允许用户传入多个标签，有任何一个标签存在就能搜索出来 or。like '%Java%' or like '%C++%'

### SQL 查询

实现简单，可以通过拆分查询进一步优化

基本思路:

拼接 SQL 语句, 执行, 数据脱敏, 返回

```java
private List<UserVO> sqlSearch(List<String> tagsList) {
    // sql 语句 like %java% and like %python%
    QueryWrapper<User> query = new QueryWrapper<>();
    for (String tag : tagsList) {
        query = query.like("tags", tag);
    }
    // 脱敏 返回
    return userMapper.selectList(query).stream().map(this::getSafetyUser).collect(Collectors.toList());
}
```

### 内存查询

灵活，可以通过并发进一步优化

基本思路:

查询全部用户, 在内存中过滤掉不符合条件的用户, 数据脱敏, 返回

```java
private List<UserVO> memorySearch(List<String> tagsList) {
    // 查询全部用户
    QueryWrapper<User> query = new QueryWrapper<>();
    List<User> userList = userMapper.selectList(query);
    // 在内存中过滤掉不符合条件的用户
    List<User> tmpUserTagsList = userList.stream().filter(user -> {
        String userTags = user.getTags();
        if (StringUtils.isBlank(userTags)) {
            return false;
        }
        Gson gson = new Gson();
        Set<String> userTagsList = gson.fromJson(userTags, new TypeToken<Set<String>>() {
        }.getType());
        for (String tag : userTagsList) {
            if (!tagsList.contains(tag)) {
                return false;
            }
        }
        return true;
    }).collect(Collectors.toList());
    // 脱敏 返回
    return tmpUserTagsList.stream().map(this::getSafetyUser).collect(Collectors.toList());
}
```

### 实际业务优化思路

> - 如果参数可以分析，根据用户的参数去选择查询方式，比如标签数量
>
> - 如果参数不可分析，并且数据库连接足够、内存空间足够，可以并发同时查询，谁先返回用谁
> - 还可以 SQL 查询与内存计算相结合，比如先用 SQL 过滤掉部分 tag