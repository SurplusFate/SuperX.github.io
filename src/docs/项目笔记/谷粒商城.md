# 谷粒商城

## 环境搭建

虚拟机, docker, docker 安装 mysql, docker 安装 redis, git

初始化数据库:

[pms_catelog.sql](环境搭建/pms_catelog.sql)

[gulimall_oms.sql](环境搭建/gulimall_oms.sql)

[gulimall_pms.sql](环境搭建/gulimall_pms.sql)

[gulimall_sms.sql](环境搭建/gulimall_sms.sql)

[gulimall_ums.sql](环境搭建/gulimall_ums.sql)

[gulimall_wms.sql](环境搭建/gulimall_wms.sql)

[sys_menus.sql](环境搭建\sys_menus.sql)

## 项目搭建

## 快速开发

人人开源或其他后台管理系统均可

人人开源后端:

[renren-fast](https://gitee.com/renrenio/renren-fast)

前端:

[renren-fast-vue](https://gitee.com/renrenio/renren-fast-vue)

前端说明文档: [Home · renrenio/renren-fast-vue Wiki (github.com)](https://github.com/renrenio/renren-fast-vue/wiki)

### 配置修改

#### 后端

修改人人开源项目的 springboot 版本, 适配 springcloud 和 springcloud alibaba

[Spring Cloud](https://spring.io/projects/spring-cloud)

![image.png](https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/202211171230387.png)

**阿里官方概述:**

如果项目中需要使用 Spring Cloud Alibaba 2021.0.1.0 版本，请在项目中添加如下依赖：

```xml
<dependencyManagement>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-dependencies</artifactId>
        <version>2.6.3</version>
        <type>pom</type>
        <scope>import</scope>
    </dependency>
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-dependencies</artifactId>
        <version>2021.0.1</version>
        <type>pom</type>
        <scope>import</scope>
    </dependency>
    <dependency>
        <groupId>com.alibaba.cloud</groupId>
        <artifactId>spring-cloud-alibaba-dependencies</artifactId>
        <version>2021.0.1.0</version>
        <type>pom</type>
        <scope>import</scope>
    </dependency>
</dependencyManagement>
```

**调整项目依赖:**

项目依赖报错可尝试调整依赖关系

```xml
<modules>
    <module>gulimall-third-party</module>
    <module>gulimall-gateway</module>
    <module>gulimall-coupon</module>
    <module>gulimall-member</module>
    <module>gulimall-order</module>
    <module>gulimall-product</module>
    <module>gulimall-ware</module>
    <module>renren-fast</module>
    <module>gulimall-common</module>
</modules>
```

**调整依赖(可选):**

视频提供的源码, 没有进行统一的依赖管理, 并且使用了两个版本的 SpringBoot, 可尝试修改为统一版本

将部分依赖和工具类抽取出来, **不是必须**, 可按照自己的喜好来

调整后会出现较多的依赖报错, 需要调整依赖

> **<font color=red>依赖迁移的时候千万不要引错包, 有的依赖有 springboot 版本和 非 springboot 版本, 引入的版本不对不会有错误提示, 在运行时会提示无法自动装配</font>**
>
> **<font color=red>抽取工具类的时候要看看配置文件有没有配置也需要抽出来, 否则其他模块启动的时候可能会报一些不好定位错误的异常</font>**
>
> 依赖和配置都最好是直接从父项目复制过去

#### 前端

修改 node 版本为大于等于 8.11.1, 如果初始化失败可尝试使用 git 克隆人人开源原项目, 初始化后再用本地代码覆盖

官方文档: [安装](https://github.com/renrenio/renren-fast-vue/wiki/Getting-started#%E5%AE%89%E8%A3%85)

![image-20221125175558950](https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/202211251755995.png)

推荐使用 nvm, 方便管理 node 版本

[nvm 文档手册 - nvm 是一个 nodejs 的版本管理工具 (uihtm.com)](https://nvm.uihtm.com/)

- `nvm arch`：显示 node 是运行在 32 位还是 64 位。
- `nvm install <version> [arch]` ：安装 node， version 是特定版本也可以是最新稳定版本 latest。可选参数 arch 指定安装 32 位还是 64 位版本，默认是系统位数。可以添加--insecure 绕过远程服务器的 SSL。
- `nvm list [available]` ：显示已安装的列表。可选参数 available，显示可安装的所有版本。list 可简化为 ls。
- `nvm on` ：开启 node.js 版本管理。
- `nvm off` ：关闭 node.js 版本管理。
- `nvm proxy [url]` ：设置下载代理。不加可选参数 url，显示当前代理。将 url 设置为 none 则移除代理。
- `nvm node_mirror [url]` ：设置 node 镜像。默认是 <https://nodejs.org/dist/>。如果不写 url，则使用默认 url。设置后可至安装目录 settings.txt 文件查看，也可直接在该文件操作。
- `nvm npm_mirror [url]` ：设置 npm 镜像。<https://github.com/npm/cli/archive/>。如果不写 url，则使用默认 url。设置后可至安装目录 settings.txt 文件查看，也可直接在该文件操作。
- `nvm uninstall <version>` ：卸载指定版本 node。
- `nvm use [version] [arch]` ：使用制定版本 node。可指定 32/64 位。
- `nvm root [path]` ：设置存储不同版本 node 的目录。如果未设置，默认使用当前目录。
- `nvm version` ：显示 nvm 版本。version 可简化为 v

错误解决:

```sh
Module build failed: Error: Node Sass does not yet support your current environment: Windows 64-bit with Unsupported runtime (83)
```

sass 不支持当前的环境，那么在当前环境重新安装一下就好了

```sh
 npm uninstall --save node-sass
```

```sh
npm install --save node-sass
```

### 代码生成器

> 生成的代码是前后端配套的, 可以直接使用

![image-20221118150002822](https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/202211181517360.png)

![image-20221125174553347](https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/202211251745402.png)

#### 后端代码调整

> 后端生成的代码实体类(`io.renren.modules.*.entity`)中可能不会标注 `@TableId` 要自己手动补充, 否则后续增删改查可能会出现 `Invalid bound statement (not found)`
>
> 官方说明: <https://baomidou.com/pages/f84a74/#%E5%87%BA%E7%8E%B0-invalid-bound-statement-not-found-%E5%BC%82%E5%B8%B8>
>
> mybatis-plus 拥有主键自动填充功能, 如果指定填充方式为 `ASSIGN_ID`, 则会采用雪花算法生成 19 位长数字, 会导致前端精度丢失(17 位以后的数字全部变 0)
>
> 手动指定填充方式: 在配置文件中指定 `id-type: AUTO`, 或者 `@TableId(type = IdType.AUTO)`

### 踩坑

#### Docker 容器突然连接不上

重启 Linux 无效, 重启 Docker 后解决

可能原因:

1. 宿主机的 IP_FORWARD 功能失效

2. 端口没开放

查看 IP_FORWARD 功能有没有启用(1 表示已经启用, 0 表示未启用)

```sh
sysctl net.ipv4.ip_forward
```

这里有可能显示是 1 但实际是 0; 将状态重置:

```sh
systemctl restart network.service
```

手动写入:

```sh
echo 'net.ipv4.ip_forward = 1' >> /usr/lib/sysctl.d/50-default.conf
```

加载配置文件:

```sh
sysctl -p /usr/lib/sysctl.d/50-default.conf
```

CentOS 7 下的一些其他相关命令:

查看 Docker 容器:

```sh
docker ps -a
```

有参数 `-a` 表示查看全部容器, 无参数表示查看正在运行的容器

查看开放的端口:

```sh
firewall-cmd --list-ports
```

查看开放的服务:

```sh
firewall-cmd --list-services
```

查看防火墙状态:

```sh
systemctl status firewalld
```

关闭防火墙:

```sh
systemctl stop firewalld
```

开启防火墙:

```sh
systemctl start firewalld
```

打开指定端口:

```sh
firewall-cmd --permanent --add-port=端口号/协议
```

例如打开 8080 端口:

```sh
firewall-cmd --permanent --add-port=8080/tcp
```

关闭端口:

```sh
firewall-cmd --permanent --remove-port=端口号/协议
```

重新载入生效:

```sh
firewall-cmd --reload
```

查询端口是否开放:

```sh
firewall-cmd --query-port=端口号/协议
```

#### <font color =red>Docker 中的数据丢失!</font>

Docker 中的 MySQL 因为一次异常停止, 在重启后所有数据全部丢失, 且查询 root 权限显示正常, 实际连建表权限都没有!

> **容器一定要挂载数据卷!**

#### Nacos2 连接不上/端口未开放

先是连接不上 nacos, 需要补充依赖:

```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-bootstrap</artifactId>
    <version>3.0.3</version>
</dependency>
```

尝试连接 nacos 的时候报了一个关于 9848 端口的错误, nacos2 还需要开放该端口:

```sh
firewall-cmd --permanent --add-port=9848/tcp
```

重新载入生效:

```sh
firewall-cmd --reload
```

如果是把 nacos 部署在 docker 中, 则需要重新创建容器并设置端口, 可以使用 idea 连接 docker, 但延迟较大

![image.png](https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/202211171222224.png)

![image.png](https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/202211171232265.png)

删除 docker 容器命令:

```sh
docker rm -f nacos
```

创建并运行 nacos 容器命令参考:

```sh
docker run \
--name nacos \
-e MODE=standalone \
-e JVM_XMS=512m \
-e JVM_XMX=512m \
-p 8848:8848 \
-p 9848:9848 \
-d nacos/nacos-server:2.0.2
```

详细配置列表:

[github.com](https://github.com/nacos-group/nacos-docker/blob/master/README_ZH.md#%E5%B1%9E%E6%80%A7%E9%85%8D%E7%BD%AE%E5%88%97%E8%A1%A8)

重启 docker 命令:

```sh
Systemctl restart docker
```

idea 中显示 docker 状态有较大延迟, 没反应可尝试重新连接 docker

#### idea 连不上 Docker 中的 MySQL5.7

![image-20221119191826977](https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/202211191918058.png)

需要添加配置

```sh
TLSv1,TLSv1.1,TLSv1.2,TLSv1.3
```

![image-20221119191758437](https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/202211191918688.png)

> **记得点应用！**

## 限制微服务内存使用

限制内存使用能有效降低电脑负载压力

![image-20221125152338482](https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/202211251523724.png)

## Windows 端口占用

查看所有占用的端口

```sh
netstat -ano
```

查看指定的端口

```sh
netstat -aon|findstr "端口号"
```

![image](https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/202211260859274.png)

查看占用端口的应用程序名称

```sh
tasklist|findstr "PID"
```

![image](https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/202211260859069.png)

杀死该程序

```sh
taskkill /f /pid PID
```

![image](https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/202211260858486.png)

## 商品服务

### 三级分类

#### 递归查询父子节点

数据库父类的 catId 就是子类的 parentId;

![image-20221118100041911](https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/202211181000192.png)

获取所有数据, 筛选出最高级父类;

```java
List<CategoryEntity> tree = categoryService.getTree();
        List<CategoryDTO> dtoTree = new ArrayList<>();
        // 全部数据
        tree.forEach(t -> dtoTree.add(BeanUtil.copyProperties(t, CategoryDTO.class)));
```

通过父类 id 和子类 parentid 进行关联;

```java
// 1. 找到所有的一级分类
List<CategoryDTO> leave1 =
        dtoTree.stream()
                .filter(r -> r.getParentCid() == 0)
                // 2. 递归获取所有子菜单
                .map(
                        r -> {
                            r.setChildren(getChildren(r, dtoTree));
                            return r;
                        }
                )
                // 3. 排序 踩坑 Integer 包装类赋值为 0 的情况下会自动转成 null
                .sorted(Comparator.comparingInt(r -> (r.getSort() == null ? 0 : 1)))
                .collect(Collectors.toList());
```

利用递归进行多级查询

```java
private List<CategoryDTO> getChildren(CategoryDTO parent, List<CategoryDTO> allData) {
    return
            allData.stream()
                    .filter(c -> c.getParentCid().equals(parent.getCatId()))
                    .map(p -> {
                        p.setChildren(getChildren(p, allData));
                        return p;
                    })
                    .sorted(Comparator.comparingInt(r -> (r.getSort() == null ? 0 : 1)))
                    .collect(Collectors.toList());
}
```

> 自动生成的代码没有遵循数据库设计规范(缺少逻辑删除, 创建时间, 更新时间这三个字段), 如果希望自动生成的的代码正常运行需要手动补加
>
> 如果后端依赖或者配置文件调整不当, 最终会导致项目默认的分页功能失效, 前端会一页展示所有数据

#### Gateway 路由配置

##### 负载均衡/错误 503

单独在 gateway 启用负载均衡需要添加 loadbalancer 依赖, 否则会报 **503 错误**:

```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-loadbalancer</artifactId>
</dependency>
```

![image-20221118162622309](https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/202211181626349.png)

##### 跨域出现 origin 重复

![image-20221118162924623](https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/202211181629661.png)

![image-20221118162951157](https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/202211181629239.png)

因为人人开源配置了默认的跨域

![image-20221126100346374](https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/202211261003099.png)

可以将默认跨域注释掉或者使用 gateway 的配置解决

> 在官方文档检索 `CORS` 可查找到相关信息

<https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#the-deduperesponseheader-gatewayfilter-factory>

![image-20221118162342771](https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/202211181623856.png)

#### 逻辑删除

除了按照 [MyBatis-Plus](https://baomidou.com/pages/6b03c5/#%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95) 官方文档的配置配好以外, 别忘记补充字段

![image-20221122091208793](https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/202211220913005.png)

### 品牌管理

#### OSS 对象存储

OSS 的依赖对 nacos 依赖有版本要求, 不然可能会报错: `Parameter 0 of method inetIPv6Util in com.alibaba.cloud.nacos.utils.UtilIPv6AutoConfiguration required a single bean, but 2 were found`

相关信息:

> [Parameter 0 of method inetIPv6Util in com.alibaba.cloud.nacos.utils.UtilIPv6AutoConfiguration required a single bean, but 2 were found: · Issue #2789 · alibaba/spring-cloud-alibaba (github.com)](https://github.com/alibaba/spring-cloud-alibaba/issues/2789)

SpringBoot 版本:

```xml
<parent>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-parent</artifactId>
    <version>2.1.8.RELEASE</version>
    <relativePath/> <!-- lookup parent from repository -->
</parent>
```

SpringBootCloud 版本 和 SpringBootCloudAlibaba 版本: :

```xml
<properties>
    <java.version>1.8</java.version>
    <spring-cloud.version>Greenwich.SR3</spring-cloud.version>
</properties>

    <!--================-->

<dependencyManagement>
    <dependencies>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-dependencies</artifactId>
            <version>${spring-cloud.version}</version>
            <type>pom</type>
            <scope>import</scope>
        </dependency>
            <dependency>
                <groupId>com.alibaba.cloud</groupId>
                <artifactId>spring-cloud-alibaba-dependencies</artifactId>
                <version>2.1.0.RELEASE</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
    </dependencies>
</dependencyManagement>
```

[版本依赖关系](https://github.com/alibaba/spring-cloud-alibaba/wiki/%E7%89%88%E6%9C%AC%E8%AF%B4%E6%98%8E#%E6%AF%95%E4%B8%9A%E7%89%88%E6%9C%AC%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8):

![image-20221122195555783](https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/202211221955132.png)

[组件版本关系](https://github.com/alibaba/spring-cloud-alibaba/wiki/%E7%89%88%E6%9C%AC%E8%AF%B4%E6%98%8E#%E7%BB%84%E4%BB%B6%E7%89%88%E6%9C%AC%E5%85%B3%E7%B3%BB):

![image-20221122195726057](https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/202211221957110.png)

简单示例:

```properties
spring.cloud.alicloud.oss.endpoint=oss-cn-shenzhen.aliyuncs.com
spring.cloud.alicloud.secret-key=6i2bWJMf********gINHyrK
spring.cloud.alicloud.access-key=LTAI********3bKNEhY
spring.cloud.alicloud.oss.bucket=bucketName
```

```java
@RestController
public class OssController {
    @Autowired
    private OSS ossClient;

    @Value("${oos.bucket}")
    private String bucketName;

    @RequestMapping("oss")
    public String home() throws IOException {
        String date = new SimpleDateFormat("yyyy-MM-dd").format(new Date());
        String filetName = String.valueOf(System.currentTimeMillis());

        ossClient.putObject(bucketName, date + "/" + filetName + ".jpg",
                Files.newInputStream(Paths.get("E:/imgs/4.jpg")));
        return "upload success";
    }
}
```

配置跨域:

[JavaScript 客户端签名直传 (aliyun.com)](https://help.aliyun.com/document_detail/31925.html)

![image-20221122204955494](https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/202211222049592.png)

项目自带的参数配置:

![image-20221122211257117](https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/202211222112735.png)

项目自带的 oss 配置, 可以做很好的参考:

![image-20221122211655333](https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/202211222116402.png)

#### JSR303 参数验证

参考: [Spring Boot 使用 JSR303 实现参数验证-阿里云开发者社区 (aliyun.com)](https://developer.aliyun.com/article/761457#slide-8)

JSR 是 Java Specification Requests 的缩写，即 Java 规范提案。

JSR-303 是 JAVA EE 6 中的一项子规范，叫做 Bean Validation。

##### Bean Validation 规范内嵌的约束注解

![181bd595afbbc00e8e2618bd485c0829bcb46fc7](https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/202211230835309.png)

##### 实例

> 1. 给 bean 属性添加 `javax.validation.constraints` 中的校验注解, 可自定义 `message` 消息
> 2. 开启校验功能 `@Valid`
> 3. 紧跟在校验的 Bean 后添加一个 `BindingResult`，`BindingResult` 封装了前面 Bean 的校验结果

给 bean 属性添加校验注解

```java
@Data
public class BrandDTO implements Serializable {
    private static final long serialVersionUID = 1L;

    private Long brandId;

    @NotBlank(message = "品牌名不能为空")
    private String name;

    @URL(message = "必须为合法的url地址")
    private String logo;

    private String descript;

    private Integer showStatus;

    @Pattern(regexp = "^[a-zA-Z]$", message = "检索首字母必须为字母")
    private String firstLetter;

    @Min(value = 0, message = "排序必须大于0")
    private Integer sort;
}
```

开启校验

```java
@PostMapping
public Result save(@Valid @RequestBody BrandDTO dto, BindingResult bindingResult) {
    if (bindingResult.hasErrors()) {
        Map<String , String> map = new HashMap<>();
        bindingResult.getFieldErrors().forEach( (item) -> {
            String message = item.getDefaultMessage();
            String field = item.getField();
            map.put( field , message );
        } );
        Result r = new Result().error(400, "error");
        r.setData(map);
        return r;
    }

    brandService.save(dto);

    return new Result();
}
```

##### 统一异常处理

```java
@Slf4j
@RestControllerAdvice(basePackages = "io.renren.modules.product.controller")
public class GlobalExceptionControllerAdvice {

    @ExceptionHandler(value= {MethodArgumentNotValidException.class , BindException.class})
    public Result handleVaildException(Exception e){
        BindingResult bindingResult = null;
        if (e instanceof MethodArgumentNotValidException) {
            bindingResult = ((MethodArgumentNotValidException)e).getBindingResult();
        } else if (e instanceof BindException) {
            bindingResult = ((BindException)e).getBindingResult();
        }
        Map<String,String> errorMap = new HashMap<>(16);
        bindingResult.getFieldErrors().forEach((fieldError)->
                errorMap.put(fieldError.getField(),fieldError.getDefaultMessage())
        );
        Result r = new Result().error(400, "error");
        r.setData(errorMap);
        return r;
    }
}
```

使用统一异常处理后就不需要逐个校验了

```java
@PostMapping
public Result save(@Valid @RequestBody BrandDTO dto) {
    brandService.save(dto);
    return new Result();
}
```

##### 分组校验

新增和修改对于实体的校验规则是不同的，例如 id 是自增的时，新增时 id 要为空，修改则必须不为空；新增和修改，若用的恰好又是同一种实体，那就需要用到分组校验

校验注解都有一个 groups 属性，可以将校验注解分组，`@NotNull` 的源码：

```java
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE })
@Retention(RUNTIME)
@Repeatable(List.class)
@Documented
@Constraint(validatedBy = { })
public @interface NotNull {

    String message() default "{javax.validation.constraints.NotNull.message}";

    Class<?>[] groups() default { };

    Class<? extends Payload>[] payload() default { };

    @Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE })
    @Retention(RUNTIME)
    @Documented
    @interface List {

        NotNull[] value();
    }
}
```

从源码可以看出 groups 是一个 Class<?>类型的数组，那么就可以创建一个 Groups.

```java
public class Groups {
    public interface Add{}
    public interface  Update{}
}
```

给 bean 属性的校验注解添加分组, 多个分组使用 `{}` 即可

```java
@Null(message = "新增不需要指定id" , groups = Groups.Add.class)
@NotNull(message = "修改需要指定id" , groups = Groups.Update.class)
@ApiModelProperty(value = "品牌id")
private Long brandId;

@URL(message = "必须为合法的url地址", groups = {UpdateGroup.class, AddGroup.class})
@ApiModelProperty(value = "品牌logo地址")
private String logo;
```

Controller 中原先的 `@Valid` 不能指定分组 ，需要替换成 `@Validated`, 并指定分组, 多个分组用 `{}` 即可

```java
@PostMapping
public Result save(@Validated(Groups.Add.class) @RequestBody BrandDTO dto) {
    brandService.save(dto);
    return new Result();
}
```

> 默认没有指定分组的校验注解在使用分组校验的情况下不会生效

##### 自定义校验注解

###### 创建约束规则

```java
@Documented
@Constraint(validatedBy = { ListValueConstraintValidator.class })
@Target({ METHOD, FIELD, ANNOTATION_TYPE })
@Retention(RUNTIME)
public @interface ListValue {
    String message() default "";

    Class<?>[] groups() default { };

    Class<? extends Payload>[] payload() default { };

    int[] vals() default { };
}
```

Bean Validation API 规范的要求：

- `message` 属性, 这个属性被用来定义默认得消息模版, 当这个约束条件被验证失败的时候, 通过此属性来输出错误信息; 可以参考官方写法自定义一个配置文件
- `groups` 属性, 用于指定这个约束条件属于哪(些)个校验组. 这个的默认值必须是 Class<?> 类型数组
- `payload` 属性, Bean Validation API 的使用者可以通过此属性来给约束条件指定严重级别. 这个属性并不被 API 自身所使用

注解信息:

- `@Target({ METHOD, FIELD, ANNOTATION_TYPE })`: 表示此注解可以被用在方法, 字段或者 annotation 声明上
- `@Retention(RUNTIME)`: 表示这个注解信息是在运行期通过反射被读取的
- `@Constraint(validatedBy = ListValueConstraintValidator.class)`: 指明使用哪个校验器(类) 去校验使用了此注解的元素
- `@Documented`: 表示在对使用了该注解的类进行 javadoc 操作到时候, 这个注解会被添加到 javadoc 当中.

###### 创建约束校验器

```java
public class ListValueConstraintValidator implements ConstraintValidator<ListValue,Integer> {

    private Set<Integer> set = new HashSet<>();
    /**
     * 初始化方法
     */
    @Override
    public void initialize(ListValue constraintAnnotation) {

        int[] vals = constraintAnnotation.vals();
        for (int val : vals) {
            set.add(val);
        }
    }

    /**
     * 判断是否校验成功
     *
     * @param value 需要校验的值
     * @param context
     * @return
     */
    @Override
    public boolean isValid(Integer value, ConstraintValidatorContext context) {

        return set.contains(value);
    }
}
```

`ListValueConstraintValidator` 定义了两个泛型参数, 第一个是这个校验器所服务到注解类型(即 `ListValue`), 第二个这个校验器所支持到被校验元素的类型 (即`Integer`)

如果一个注解支持多种类型的被校验元素的话, 那么需要为每个所支持的类型定义一个 `ConstraintValidator`, 并且注册到注解中

使用自定义注解:

```java
@ListValue( message = "显示状态[0-不显示；1-显示]1" , vals = {0,1} , groups = {Groups.Add.class , Groups.Update.class})
private Integer showStatus;
```

### 属性分组

#### 接口文档

地址: <https://easydoc.xyz/#/s/78237135>

#### 分页查询动态参数

和传统分页区别不大

```java
String key = (String) params.get("key");
// select * from pms_attr_group where catelog_id = ?
QueryWrapper<AttrGroupEntity> wrapper = new QueryWrapper<AttrGroupEntity>().eq("catelog_id", catelogId);
// and (attr_group_id = key or attr_group_name like %key%)
if (StringUtils.isNotBlank(key)) {
    wrapper.and(attrGroupDTOQueryWrapper -> attrGroupDTOQueryWrapper
            .eq("attr_group_id", key)
            .or().like("attr_group_name", key));
}
```

#### 排除 bean 的空属性

```java
@JsonInclude(JsonInclude.Include.NON_EMPTY)
@ApiModelProperty(value = "子节点")
private List<CategoryDTO> children;
```

#### 递归获取父节点

```java
@Override
public Long[] findCatelogPath(Long catelogId) {
    List<Long> list = new ArrayList<>();
    List<Long> longList = findParents(catelogId, list);

    // list 强转 array
    return longList.toArray(new Long[0]);
}

private List<Long> findParents(Long catelogId, List<Long>  list) {
    // 搜集当前节点id
    list.add(catelogId);
    CategoryDTO byId = this.get(catelogId);
    if (byId.getParentCid() != 0){
        findParents(byId.getParentCid(), list);
    }
    return list;
}
```

#### 多对多的数据同步

![image-20221124195046906](https://gcore.jsdelivr.net/gh/SurplusFate/guide_img@main/img/202211241950232.png)

利用数据表的冗余字段来避免多对多的低效率关联查询

`pms_category_brand_relation` 中的数据只能是 `pms_category` 和 `pms_brand` 中已经有的

```java
@Override
public void saveDetails(CategoryBrandRelationDTO dto) {
    Long brandId = dto.getBrandId();
    Long catelogId = dto.getCatelogId();

    BrandEntity brand = brandDao.selectById(brandId);
    CategoryEntity category = categoryDao.selectById(catelogId);

    dto.setBrandName(brand.getName());
    dto.setCatelogName(category.getName());

    this.save(dto);
}
```

`pms_brand` 中的数据更新时需要同步更新中间表的数据

`BrandServiceImpl`:

```java
@Transactional
@Override
public void updateDetail(BrandDTO dto){
    // 更新商品信息
    this.update(dto);
    if (StringUtils.isNotEmpty(dto.getName())) {
        // 更新中间表
        categoryBrandRelationService.updateBrand(dto.getBrandId(), dto.getName());
    }
    //todo 其他关联表
}
```

`CategoryBrandRelationServiceImpl`:

```java
@Transactional
@Override
public void updateBrand(Long brandId, String name) {
    CategoryBrandRelationDTO categoryBrandRelationDTO = new CategoryBrandRelationDTO();
    CategoryBrandRelationEntity categoryBrandRelationEntity = ConvertUtils.sourceToTarget(categoryBrandRelationDTO, currentModelClass());
    UpdateWrapper<CategoryBrandRelationEntity> updateWrapper = new UpdateWrapper<>();
    updateWrapper.set("brand_name", name).eq("brand_id", brandId);
    update(categoryBrandRelationEntity, updateWrapper);
}
```

`pms_category_brand_relation` 中的数据更新时需要同步更新 `pms_category`

`CategoryBrandRelationServiceImpl`:

```java
@Transactional
@Override
public void updateDetails(CategoryBrandRelationDTO dto) {
    update(dto);
    CategoryEntity category = new CategoryEntity();
    UpdateWrapper<CategoryEntity> updateWrapper = new UpdateWrapper<>();
    updateWrapper.set("name", dto.getCatelogName()).eq("cat_id", dto.getCatelogId());
    categoryDao.update(category, updateWrapper);
}
```

`pms_category` 中的数据更新时需要同步更新 `pms_category_brand_relation`

`CategoryServiceImpl`:

```java
@Transactional
@Override
public void updateCascade(CategoryDTO dto) {
    update(dto);
    categoryBrandRelationService.updateCategory(dto.getName(), dto.getCatId());
}
```

`CategoryBrandRelationServiceImpl`:

```java
@Transactional
@Override
public void updateCategory(String name, Long catId) {
    baseDao.updateCategory(name, catId);
}
```

`CategoryBrandRelationDao`:

```xml
<update id="updateCategory">
    update pms.pms_category_brand_relation set catelog_name = #{name} where catelog_id = #{catId}
</update>
```

### 新增商品

#### 远程调用优惠券模块

在 `product` 模块的启动类上添加注解 `@EnableFeignClients` 开启远程调用

```java
@EnableFeignClients(basePackages = "io.renren.feign")
@SpringBootApplication
public class ProductApplication {

    public static void main(String[] args) {
        SpringApplication.run(ProductApplication.class, args);
    }
}
```

编写调用接口

```java
@FeignClient("coupon")
public interface CouponFeignService {
    @PostMapping("coupon/smscoupon")
    Result saveSpuBounds(@RequestBody SpuInfoDTO data);
}
```

通过 `@FeignClient("coupon")` 去 nacos 找到 `coupon` 服务, 并发送 `@PostMapping("coupon/smscoupon")` 请求, 请求将 `SpuInfoDTO` 自动转换为 `json` 对象作为请求体传输, 也就是说 `coupon` 服务在接收时不需要一定是 `SpuInfoDTO` 对象, 只要能兼容就行

> - 服务名称：coupon
> - 请求方式：Post
> - 请求路径：coupon/smscoupon
> - 请求参数：SpuInfoDTO data
> - 返回值类型：Result

## 整合 ElasticSearch8

官方文档:

<https://www.elastic.co/guide/en/elasticsearch/client/java-api-client/7.16/introduction.html#introduction>

### 环境准备

```xml
<properties>
    <java.version>1.8</java.version>
    <!--排除springboot默认的版本, 防止依赖冲突-->
    <elasticsearch.version>8.5.1</elasticsearch.version>
</properties>

<dependency>
    <groupId>co.elastic.clients</groupId>
    <artifactId>elasticsearch-java</artifactId>
    <version>8.5.1</version>
</dependency>

<dependency>
    <groupId>com.fasterxml.jackson.core</groupId>
    <artifactId>jackson-databind</artifactId>
    <version>2.12.3</version>
</dependency>

<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
</dependency>
```

配置文件

```properties
search.http_host=192.168.202.100
search.http_port=9200
```

自动装配

```java
@Configuration
public class SearchConfig {

    @Value("${search.http_host}")
    private String searchHost;

    @Value("${search.http_port}")
    private int port;

    @Bean
    public ElasticsearchClient configClint() {
        // Create the low-level client
        RestClient restClient = RestClient.builder(
                new HttpHost(searchHost, port)).build();

        // Create the transport with a Jackson mapper
        ElasticsearchTransport transport = new RestClientTransport(
                restClient, new JacksonJsonpMapper());

        // And create the API client
        return new ElasticsearchClient(transport);
    }
}
```

准备一个实体类

```java
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Product {
    private String sku;
    private String name;
    private double price;
}
```

### 建立索引

[单对象建立索引](https://www.elastic.co/guide/en/elasticsearch/client/java-api-client/current/indexing.html#indexing)

> 重复插入会覆盖相同 id 的数据

```java
@Slf4j
@RunWith(SpringRunner.class)
@SpringBootTest
public class SearchConfigTest {

    @Autowired
    private ElasticsearchClient client;

    @Test
   public void createHotelIndex() throws IOException {
        // 方法1 DSL
        Product product = new Product("bk-1", "City bike", 123.0);

        IndexResponse response = client.index(i -> i
                .index("products")
                .id(product.getSku())
                .document(product)
        );

        log.info("Indexed with version: {}", response.version());
       // ======================================================================

        // 方法2 使用 IndexRequest
        Product product2 = new Product("bk-2", "City bike2", 1230.0);

        IndexRequest<Product> request = IndexRequest.of(i -> i
                .index("products")
                .id(product2.getSku())
                .document(product2)
        );

        IndexResponse response2 = client.index(request);

        log.info("Indexed with version: {}", response2.version());
        // =========================================================================

        // 方法3 使用 构造器
        Product product3 = new Product("bk-3", "City bike3", 1233.0);

        IndexRequest.Builder<Product> indexReqBuilder = new IndexRequest.Builder<>();
        indexReqBuilder.index("product3");
        indexReqBuilder.id(product3.getSku());
        indexReqBuilder.document(product3);

        IndexResponse response3 = client.index(indexReqBuilder.build());

        log.info("Indexed with version: {}", response3.version());

        // 操作 json
        Reader input = new StringReader(
                "{'@timestamp': '2022-04-08T13:55:32Z', 'level': 'warn', 'message': 'Some log message'}"
                        .replace('\'', '"'));

        IndexRequest<JsonData> request2 = IndexRequest.of(i -> i
                .index("logs")
                .withJson(input)
        );

        IndexResponse response4 = client.index(request2);

        log.info("Indexed with version: {}", response4.version());
    }
}
```

[批量建立索引](https://www.elastic.co/guide/en/elasticsearch/client/java-api-client/current/indexing-bulk.html#indexing-bulk)

```java
@Slf4j
@RunWith(SpringRunner.class)
@SpringBootTest
public class SearchConfigTest {

    @Autowired
    private ElasticsearchClient client;

    @Test
    public void createHotelIndex() throws IOException {

        List<Product> products = fetchProducts();

        BulkRequest.Builder br = new BulkRequest.Builder();

        for (Product product5 : products) {
            br.operations(op -> op                //[1]
                    .index(idx -> idx             //[2]
                            .index("products")    //[3]
                            .id(product5.getSku())
                            .document(product5)
                    )
            );
        }

        // 允许在单个请求中执行多个索引/更新/删除操作。
        BulkResponse result = client.bulk(br.build());

        // Log errors, if any
        if (result.errors()) {
            log.error("Bulk had errors");
            for (BulkResponseItem item : result.items()) {
                if (item.error() != null) {
                    log.error(item.error().reason());
                }
            }
        }
    }
}
```

1. 表明是批量建立, 最终将实体对象都添加到了 `operations` 集合中

2. `ObjectBuilder`, 初始化 `Kind` 和 `value`, `kind` 是个枚举: `Index("index")`, `Create("create")`, `Update("update")`, `Delete("delete")` value 是 `operation`

3. 类似于单个文档索引：索引名称、标识符和[文档](https://www.elastic.co/guide/en/elasticsearch/client/java-api-client/current/indexing.html)

> 简单概述: 收集数据并统一封装好, 最终通过 `client.bulk` 一并提交
>
> 该方法也能建立单索引

### 按 ID 读取

```java
@Test
public void test() throws IOException {

    GetResponse<Product> response6 = client.get(g -> g
                    .index("products")  // [1]
                    .id("bk-1"),
            Product.class               // [2]
    );

    if (response6.found()) {
        Product product5 = response6.source();
        log.info("Product name " + product5.getName());
    } else {
        log.info ("Product not found");
    }
    // =========================================================

    // json对象
     GetResponse<ObjectNode> response7 = client.get(g -> g
                    .index("products")
                    .id("bk-2"),
            ObjectNode.class
    );

    if (response7.found()) {
        ObjectNode json = response7.source();
        String name = json.get("name").asText();
        log.info("Product name " + name);
    } else {
        log.info("Product not found");
    }
}
```

1. 目标索引
2. 实体类

### 搜索

```java
String searchText = "bike";

SearchResponse<Product> response = esClient.search(s -> s
    .index("products")
    .query(q -> q
        .match(t -> t
            .field("name")
            .query(searchText)
        )
    ),
    Product.class
);

TotalHits total = response.hits().total();
boolean isExactResult = total.relation() == TotalHitsRelation.Eq;

if (isExactResult) {
    log.info("There are " + total.value() + " results");
} else {
    log.info("There are more than " + total.value() + " results");
}

List<Hit<Product>> hits = response.hits().hits();
for (Hit<Product> hit: hits) {
    Product product = hit.source();
    log.info("Found product " + product.getSku() + ", score " + hit.score());
}
```

条件搜索

```java
String searchText = "bike";
double maxPrice = 200.0;

// Search by product name
Query byName = MatchQuery.of(m -> m
    .field("name")
    .query(searchText)
)._toQuery();

// Search by max price
Query byMaxPrice = RangeQuery.of(r -> r
    .field("price")
    .gte(JsonData.of(maxPrice))
)._toQuery();

// Combine name and price queries to search the product index
SearchResponse<Product> response = esClient.search(s -> s
    .index("products")
    .query(q -> q
        .bool(b -> b
            .must(byName)
            .must(byMaxPrice)
        )
    ),
    Product.class
);

List<Hit<Product>> hits = response.hits().hits();
for (Hit<Product> hit: hits) {
    Product product = hit.source();
    log.info("Found product " + product.getSku() + ", score " + hit.score());
}
```
